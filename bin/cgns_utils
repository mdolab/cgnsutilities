#!/usr/bin/env python
"""
This is the new gateway program to all of the cgns_utils.

Run cgns_utils -help to get a list of all available options. The basic
idea is as follows:

                                              | write new file
read cngs file -> Do some operations on it -> |     .or.
                                              | write modified file
Developed by Dr. Gaetan K. W. Kenway
"""
from __future__ import print_function, division
import sys
import os
import copy
import shutil
import tempfile
import argparse
import numpy
import libcgns_utils
import time

# List out all of the possible options here.
parser = argparse.ArgumentParser(prog='cgns_utils')


subparsers = parser.add_subparsers(
    help='Choose one of the listed operations to perform', dest='mode')

# ------------- Options for 'scale' mode --------------------
p_scale = subparsers.add_parser('scale',
                                help='Scale a grid by a constant factor')
p_scale.add_argument('gridFile', help='Name of input CGNS file')
p_scale.add_argument('scale', help='scale factor', type=float)
p_scale.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'flip' mode --------------------
p_flip = subparsers.add_parser('flip', help='Flip a grid about a plane defined \
by an axis')
p_flip.add_argument('gridFile',
                    help='Name of input CGNS file')
p_flip.add_argument('axis', help="Flip the mesh about plane defined by \
axis: 'x', 'y', 'z'")
p_flip.add_argument('outFile', nargs='?', default=None,
                    help='Optional output file')

# ------------- Options for 'coarsen' mode --------------------
p_coarsen = subparsers.add_parser('coarsen', help='Coarsen a grid uniformly')
p_coarsen.add_argument('gridFile', help='Name of input CGNS file')
p_coarsen.add_argument('outFile', nargs='?', default=None,
                       help='Optional output file')

p_refine = subparsers.add_parser('refine', help='Refine a grid uniformly')
p_refine.add_argument('gridFile', help='Name of input CGNS file')
p_refine.add_argument('outFile', nargs='?', default=None,
                      help='Optional output file')

# ------------- Options for 'extract' mode --------------------
p_extract = subparsers.add_parser('extract',
                                  help='Extract a wall surface from file')
p_extract.add_argument('gridFile', help='Name of input CGNS file')
p_extract.add_argument('surfFile', help='Name of plot3d surface file')

# ------------- Options for 'mirror' mode --------------------
p_mirror = subparsers.add_parser('mirror',
                                 help='Mirror a grid about a plane defined \
                                 by an axis. This doubles the grid size')
p_mirror.add_argument('gridFile', help='Name of input CGNS file')
p_mirror.add_argument('axis',
                      help="Mirror about plane defined by axis: 'x', 'y', 'z'")
p_mirror.add_argument('outFile', nargs='?', default=None,
                      help='Optional output file')

# ------------- Options for 'split' mode --------------------
p_split = subparsers.add_parser('split',
                                help='Face-match a grid. If the grid is \
                                already faced matched, this witll have no \
                                effect')
p_split.add_argument('gridFile', help='Name of input CGNS file')
p_split.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_split.add_argument('--splitFile', nargs='?', default=None,
                     help='Add additional splits specified in split file. Each\
                     line must contain a block index (1 based), idim (1, 2, or 3),\
                     and a 1-based index of the block to split at')

# ------------- Options for 'merge' mode --------------------
p_merge = subparsers.add_parser('merge',
                                help='Automatically merge as many blocks as possible.\
                                Boundary conditions and family information is kept.')
p_merge.add_argument('gridFile', help='Name of input CGNS file')
p_merge.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'connect' mode --------------------
p_connect = subparsers.add_parser(
    'connect', help='Determine the block-to-block connectivity information \
    for a point-matched grid')
p_connect.add_argument('gridFile', help='Name of input CGNS file')
p_connect.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'divide' mode --------------------
p_divide = subparsers.add_parser(
    'divide', help='Divide all blocks in the grid into 8 sub-blocks')
p_divide.add_argument('gridFile', help='Name of input CGNS file')
p_divide.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'autobc' mode --------------------
p_bc = subparsers.add_parser(
    'autobc', help='Try to determine boundary conditions for blocks. Only \
    suitable for external flow applications.')
p_bc.add_argument('gridFile', help='Name of input CGNS file')
p_bc.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_bc.add_argument('radius', help='Radius of sphere containing bodies',
                  type=float, default=10.0)
p_bc.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_bc.add_argument('--xOffset', nargs='?', default=0.0, type=float,
                     help='x-coordinate of sphere origin')
p_bc.add_argument('--yOffset', nargs='?', default=0.0, type=float,
                     help='y-coordinate of sphere origin')
p_bc.add_argument('--zOffset', nargs='?', default=0.0, type=float,
                     help='z--coordinate of sphere origin')

# ------------ Options for 'family' mode --------------------
p_fam = subparsers.add_parser(
    'family', help='Overwrite family information')
p_fam.add_argument('gridFile', help='Name of input CGNS file')
p_fam.add_argument('familyFile', help='File containing additional family \
information. Format is (one per line, 1-based blockID): blockID, \
{iLow, iHigh etc}, newFamilyName')
p_fam.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'familycopy' mode --------------------
p_fam = subparsers.add_parser(
    'familycopy', help='Copy family information from two otherwise identical grids')
p_fam.add_argument('gridFile', help='Name of CGNS file to which family information is to be copied')
p_fam.add_argument('sourceFile', help='Name of output CGNS file which contains family information')
p_fam.add_argument('outFile', nargs='?', default=None,
                    help='Optional output file')

# ------------ Options for 'overwritebc' mode --------------------
p_sub = subparsers.add_parser(
    'overwritebc', help='Overwrite boundary condition information', formatter_class=argparse.RawTextHelpFormatter)
p_sub.add_argument('gridFile', help='Name of input CGNS file')
p_sub.add_argument('bcFile', help="File containing additional bc info. The\
File must consist of one or more lines contaning the following data: \n\
<block number> <faceID> <BCType> <family> [key value, ....] \n \
\n\
where: \n\
block number is the block index *IN 1 BASED NUMBERING* \n\
faceID is one of iLow, iHigh jLow, jHigh, kLow or kHigh \n\
BCType is one of the supported CGNS boundary conditions. The supported \n\
BCs are : bcfarfield, bcsymmetryplane bcwall, bcwallinviscid, bcwallviscous \n\
   bcwallviscousheatflux, bcwallviscousisothermal, bcoutflow, bcoutflowsubsonic \n\
   bcinflowsubsonic \n\
family is the family name. \n\
Optionally, additional data may be specified using (key value) pairs. These \n\
can be used to set additional boundary condition data. \n\
\n\
Example lines are as follows: \n\
\n\
7 kLow bcwallviscous wing \n\
4 jHigh bcsymmetryplane sym\n\n")
p_sub.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'rebunch' mode --------------------
p_bunch = subparsers.add_parser(
    'rebunch', help='Rebunch offwall spacing (experimental')
p_bunch.add_argument('gridFile', help='Name of input CGNS file')
p_bunch.add_argument('spacing', help='The desired off-wall spacing', type=float)
p_bunch.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_bunch.add_argument('--extraCells', help='Number of additional cells to \
use in re-bunching. *SHOULD BE A MG NUMBER*.', type=int, default=0)
p_bunch.add_argument('--nodes', help="Only rebunch the first 'nodes' in the \
offwall direction", type=int, default=1)

# ------------ Options for 'cgns2plot3d' mode --------------------
p3d = subparsers.add_parser(
    'cgns2plot3d', help='Convert a cgns file to a plain plot3d file')
p3d.add_argument('gridFile', help='Name of input CGNS file')
p3d.add_argument('plot3dFile', help='Name of output plot3d file')

# ------------ Options for 'randomize' mode --------------------
p_ran = subparsers.add_parser(
    'randomize', help='Randomize the block orientation and order. Useful for testing.')
p_ran.add_argument('gridFile', help='Name of input CGNS file')
p_ran.add_argument('seed', type=int, default=0, help='Seed for random generator. \
Specifying a seed will make process deterministic.')
p_ran.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'reorder' mode --------------------
p_reorder = subparsers.add_parser(
    'reorder', help='Sort blocks in an alpha-numerical order. It can also add extra digits \
    to the integers at the end of the block names to facilitate ordering.')
p_reorder.add_argument('gridFile', help='Name of input CGNS file')
p_reorder.add_argument('intDigits', type=int, default=5, help="Number of digits used for the integers. \n\
When CGNSlib generates a CGNS file \n\
(when converting from a plot3d file, for instance), it does not add extra digits to the integers \n\
when naming zones. This becomes a problem when you have more than 10 zones because the ordering will be: \n\
Zone1, Zone11, Zone12, ..., Zone19, Zone2, Zone21, ...\n\
This method will add extra digits to the zone names to give the correct ordering.")
p_reorder.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'symmzero' mode --------------------
p_sym = subparsers.add_parser(
    'symmzero', help='Hard-zero any nodes within a given tolerance. Used for ensuring planar symmetry planes.')
p_sym.add_argument('gridFile', help='Name of input CGNS file')
p_sym.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_sym.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'timecombine' mode  --------------------
p_tc = subparsers.add_parser(
    'timecombine', help='Combine cgns files from time accurate simulation into unsteady tecplot file.')
p_tc.add_argument('baseName', help="baseName of the files. Use %%d to denote the counter.")
p_tc.add_argument('outFile', nargs='?', default=None,
                     help='Output file name. If not given, unsteady.plt is used')

# ------------ Options for 'double2d' mode  --------------------
p_dd = subparsers.add_parser(
    'double2d', help='Take a 2d mesh one cell wide and make it two cells wide.')
p_dd.add_argument('gridFile', help='Name of input CGNS file')
p_dd.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'combine' mode  --------------------
p_dd = subparsers.add_parser(
    'combine', help='Take 2 or more cgns files and combine them into a single file.')
p_dd.add_argument('gridFiles', metavar='files', type=str, nargs='+', help='Name of CGNS files to combine')
p_dd.add_argument('outFile', type=str, help='Output CGNS file name')

# ------------ Options for 'explode' mode  --------------------
p_exp = subparsers.add_parser(
    'explode', help='Take one multiblock cgns file and explodes it into single-block cgns files.')
p_exp.add_argument('gridFile', type=str, help='Name of input multiblock CGNS file')
p_exp.add_argument('outFile', nargs='?', default=None, help='Optional reference to name output files. \n\
An integer will be added to the end. \n\
if none is given, the input filename will be used as reference. \n\
All connectivity information between different blocks is lost in this step. Only \n\
internal connectivity remains.')

# ------------ Options for 'explodeKmin' mode  --------------------
p_expkmin = subparsers.add_parser(
    'explodeKmin', help='Take one multiblock cgns file and explodes it into single-block plot3d files that contains \n\
    only the K=1 faces.')
p_expkmin.add_argument('gridFile', type=str, help='Name of input multiblock CGNS file')
p_expkmin.add_argument('outFile', nargs='?', default=None, help='Optional reference to name output files. \n\
An integer will be added to the end. \n\
if none is given, the input filename will be used as reference.')

# ------------ Options for 'cartesian' mode --------------------
p_cart = subparsers.add_parser(
    'cartesian', help='Generates a background cartesian mesh', formatter_class=argparse.RawTextHelpFormatter)
p_cart.add_argument('gridFile', help='Name of input CGNS file')
p_cart.add_argument('cartFile', help="File containing background mesh info. The file must consist of \n\
4 lines contaning the following data: \n\
  <extensionXneg> <extensionYneg> <extensionZneg> \n\
  <extensionXpos> <extensionYpos> <extensionZpos> \n\
  <numNodesX> <numNodesY> <numNodesZ> \n\
  <weightGRX> <weightGRY> <weightGRZ> \n\
\n\
where: \n\
extension is the distance of the cartesian box\n\
  face to the corresponding bounding box face divided by the\n\
  bounding box length. We need 2 values of extension per \n\
  direction as we have two parallel faces for each one of them.\n\
numNodes is the number of nodes that should be used along the \n\
  edges of the cartesian mesh. If you want one symmetry plane\n\
  in the z direction, for instance, you need to set one of the\n\
  extensionZ values to 0. If you want two symmetry planes in\n\
  the z direction, (e.g. to run a 2D case) you need to set both\n\
  extensionZ values to 0.\n\
weightGR are values between 0.0 and 1.0 used to balance edge\n\
  growth ratio and cell volume resolution mismatch during the\n\
  optimization. If weightGR = 0, the optimizer will not care\n\
  about the growth ratios at the farfield and will just try\n\
  to match the bounding box resolution. If weightGR = 1, the\n\
  optimizer will not care about the bounding box resolution\n\
  and will just try to get an uniform growth ratio. This\n\
  results in an uniform mesh.\n\n\
example:\n\
  10 10 0\n\
  10 10 10\n\
  65 65 65\n\
  0.1 0.1 0.1\n")
p_cart.add_argument('outFile', help='Name of output CGNS file \n\
The output file contains only one cartesian block. The input \n\
mesh is not included and BCs are applied.\n')

# ------------ Options for 'simpleCart' mode --------------------
p_sub = subparsers.add_parser(
    'simpleCart', help='Generates a background cartesian mesh', formatter_class=argparse.RawTextHelpFormatter)
p_sub.add_argument('gridFile', help='Name of input CGNS file')
p_sub.add_argument('dh', help='Uniform spacing size', type=float)
p_sub.add_argument('hExtra', help='Extension in each dimension', type=float)
p_sub.add_argument('nExtra', help='Number of nodes to use for extension', type=int)
p_sub.add_argument('sym', help='Normal for possible sym plane', type=str)
p_sub.add_argument('mgcycle', help='Minimum MG cycle to enforce', type=int)
p_sub.add_argument('outFile', help='Name of output CGNS file')

# ------------ Options for 'simpleOCart' mode --------------------
p_sub = subparsers.add_parser(
    'simpleOCart', help='Generates a background cartesian mesh surrounding by an OMesh', formatter_class=argparse.RawTextHelpFormatter)
p_sub.add_argument('gridFile', help='Name of input CGNS file')
p_sub.add_argument('dh', help='Uniform cartesian spacing size', type=float)
p_sub.add_argument('hExtra', help='Extension in "O" dimension', type=float)
p_sub.add_argument('nExtra', help='Number of nodes to use for extension', type=int)
p_sub.add_argument('sym', help='Normal for possible sym plane', type=str)
p_sub.add_argument('mgcycle', help='Minimum MG cycle to enforce', type=int)
p_sub.add_argument('outFile', help='Name of output CGNS file')

# ------------ Options for 'translate' mode  --------------------
p_t = subparsers.add_parser(
    'translate', help='Translate a grid.')
p_t.add_argument('gridFile', help='Name of input CGNS file')
p_t.add_argument('dx', help='x-displacement', type=float)
p_t.add_argument('dy', help='y-displacement', type=float)
p_t.add_argument('dz', help='z-displacement', type=float)
p_t.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'autoOversetBC' mode
p_obc = subparsers.add_parser(
    'autoOversetBC', help='Automatically generate connectivity and boundary conditions'
    'for an overset near field mesh generated by pyHyp. It assumes the surface is a '
    'BCWallViscous and the outer boundary is a BCOverset condtiion.'
    'Only used with pyHyp hyperbolically generated meshes.')
p_obc.add_argument('gridFile', help='Name of input CGNS file')
p_obc.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_obc.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')


# ------------ Options for 'autoNearfieldBC' mode
p_anf = subparsers.add_parser(
    'autoNearfieldBC', help='Automatically generate connectivity and boundary conditions'
    'for an overset near field mesh with possible symmetry plane.')
p_anf.add_argument('gridFile', help='Name of input CGNS file')
p_anf.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_anf.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'autoFarfieldBC' mode
p_anf = subparsers.add_parser(
    'autoFarfieldBC', help='Automatically generate connectivity and boundary conditions'
    'for an overset farfield mesh with possible symmetry plane.')
p_anf.add_argument('gridFile', help='Name of input CGNS file')
p_anf.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_anf.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'include' mode
p_inc = subparsers.add_parser(
    'include', help='Write a new file including only the zones specified the given numbers/ranges.')
p_inc.add_argument('gridFile', help='Name of input CGNS file')
p_inc.add_argument('rangeSpec', help='Range to extract. Comma separated list. \
Ranges can given like 6-8. Must be 1 based. Exampe: rangeSpec=4,5,9-16,19')
p_inc.add_argument('outFile', help='Output file')

# ------------ Options for 'section' mode
p_sec = subparsers.add_parser(
    'section', help='For cgns files with 1 domain ONLY, write a subsection of the\
zone. Boundary conditions/B2Bs are deleted.')
p_sec.add_argument('gridFile', help='Name of input CGNS file')
p_sec.add_argument('iStart', type=int)
p_sec.add_argument('iEnd', type=int)
p_sec.add_argument('jStart', type=int)
p_sec.add_argument('jEnd', type=int)
p_sec.add_argument('kStart', type=int)
p_sec.add_argument('kEnd', type=int)
p_sec.add_argument('outFile', nargs='?', default=None,
                   help='Optional output file')

# ------------ Options for 'info' mode
p_info = subparsers.add_parser(
    'info', help='Print some metrics for the CGNS file.')
p_info.add_argument('gridFile', help='Name of input CGNS file')

# Finally get the arguments we need!
args = parser.parse_args()

# These are taken from the CNGS include file (cgnslib_f.h in your cgns library folder)
BC = {'bcfarfield':7,
      'bcsymmetryplane':16,
      'bcwall':20,
      'bcwallinviscid':21,
      'bcwallviscous':22,
      'bcwallviscousheatflux':23,
      'bcwallviscousisothermal':24,
      'bcoutflow':13,
      'bcoutflowsubsonic':14,
      'bcoutflowsupersonic':15,
      'bcinflowsubsonic':10,
      'bcoverset':1} #The Overset BC will be considered as a CG_USERDEFINED option ()

CG_MODE_READ = 0
CG_MODE_WRITE = 1

class Grid(object):
    """Represent a complete 3D multiblock grid"""
    def __init__(self):
        self.blocks = []
        self.topo = None

    def printInfo(self):
        """Print some information on the mesh to screen. Specifically
        information needed by the drag prediction workshop"""
        totalCells = 0
        totalNodes = 0
        for blk in self.blocks:
            totalCells += (blk.dims[0]-1)*(blk.dims[1]-1)*(blk.dims[2]-1)
            totalNodes += blk.dims[0]*blk.dims[1]*blk.dims[2]
            
        print ('Grid Info: %s'%args.gridFile)
        print ('Total Zones:', len(self.blocks))
        print ('Total Cells:', totalCells)
        print ('Total Nodes:', totalNodes)

        boundaryNodes = 0
        boundaryCells = 0
        wallBCs = [BC['bcwallviscous'], BC['bcwall'], BC['bcwallinviscid'], 
                   BC['bcwallviscousheatflux'], BC['bcwallviscousisothermal']]
        for blk in self.blocks:
            for boco in blk.bocos:
                if boco.type in wallBCs:
                    ptRange = boco.ptRange
                    if ptRange[0, 0] == ptRange[0, 1]:
                        boundaryCells += (ptRange[1, 1] - ptRange[1, 0])* \
                                         (ptRange[2, 1] - ptRange[2, 0])

                        boundaryNodes += (ptRange[1, 1] - ptRange[1, 0] +1)* \
                                         (ptRange[2, 1] - ptRange[2, 0] +1)

                    elif ptRange[1, 0] == ptRange[1, 1]:
                        boundaryCells += (ptRange[0, 1] - ptRange[0, 0])* \
                                         (ptRange[2, 1] - ptRange[2, 0])

                        boundaryNodes += (ptRange[0, 1] - ptRange[0, 0] +1)* \
                                         (ptRange[2, 1] - ptRange[2, 0] +1)

                    elif ptRange[2, 0] == ptRange[2, 1]:
                        boundaryCells += (ptRange[0, 1] - ptRange[0, 0])* \
                                         (ptRange[1, 1] - ptRange[1, 0])

                        boundaryNodes += (ptRange[0, 1] - ptRange[0, 0] +1)* \
                                         (ptRange[1, 1] - ptRange[1, 0] +1)


        print ('Wall Boundary Cells:', boundaryCells)
        print ('Wall Boundary Nodes:', boundaryNodes)
        
        
    def addBlock(self, blk):

        """Add a block to the grid"""
        self.blocks.append(blk)

    def writeToCGNS(self, fileName):
        """Write what is in this grid tree to the fileName provided"""
        outFile = libcgns_utils.openfile(fileName, CG_MODE_WRITE)
        for blk in self.blocks:
            blk.writeToCGNS(outFile)
        libcgns_utils.closefile(outFile)

    def writeToCGNSSelected(self, fileName, toWrite):
        """Write what is in this grid tree to the fileName provided"""
        outFile = libcgns_utils.openfile(fileName, CG_MODE_WRITE)
        for iblk in toWrite:
            self.blocks[iblk-1].writeToCGNS(outFile)
        libcgns_utils.closefile(outFile)

    def writePlot3d(self, fileName):
        """Write what is in this grid tree to the plot3d filename
        provided. This is mostly done in python so will be slow-ish."""
        f = open(fileName, 'w')
        f.write('%d\n'% len(self.blocks))
        for blk in self.blocks:
            blk.writeDimsPlot3d(f)
        for blk in self.blocks:
            blk.writeCoordsPlot3d(f)
        f.close()
        
    def scale(self, scaleFact):
        """Scale blocks in this grid"""
        for blk in self.blocks:
            blk.scale(scaleFact)
            
    def flip(self, axis):
        """Flip the grid about a axis, 'x', 'y' or 'z'"""
        for blk in self.blocks:
            blk.flip(axis)

    def coarsen(self):
        """Coarsen the block by taking every-other grid line"""
        for blk in self.blocks:
            blk.coarsen()
            
    def refine(self):
        """Refine he block by interpolating every-other grid line"""
        for blk in self.blocks:
            blk.refine()
                
    def renameBlocks(self):
        """Rename all blocks in a consistent fashion"""
        i = 1
        for blk in self.blocks:
            blk.name = 'domain.%5.5d'% i
            i += 1
    def renameBCs(self):
        """Rename all block boundary conditions in a consistent fashion"""
        i = 1
        for blk in self.blocks:
            for boco in blk.bocos:
                boco.name = 'BC%d'% i
                i += 1
                
    def extractSurface(self, fileName):
        """ Extract wall surfaces and write to plot3d file"""
        patches = []
        for blk in self.blocks:
            patches.extend(blk.extractWallSurfaces())
        if len(patches) > 0:
            f = open(fileName, 'w')
            f.write('%d\n' % len(patches))
            for i in range(len(patches)):

                f.write('%d %d 1\n' %(patches[i].shape[0], 
                                      patches[i].shape[1]))
            for i in range(len(patches)):
                patches[i][:, :, 0].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
                patches[i][:, :, 1].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
                patches[i][:, :, 2].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
            f.close()
        else:
            print ('Warning: No wall surfaces found!')

    def overwriteFamilies(self, familyFile):
        """Overwrite families of BC with information given in the
        family file"""
        fams = []
        f = open(familyFile,'r')
        for line in f:
            aux = line.split()
            if len(aux) == 3:
                fams.append([int(aux[0]), aux[1].lower(), aux[2]])
        f.close()

        for fam in fams:
            self.blocks[fam[0]-1].overwriteFamily(fam[1], fam[2])

    def copyFamilyInfo(self, otherGrid):
        """Copy family information out of another grid"""
        for i in range(len(self.blocks)):
            for j in range(len(self.blocks[i].bocos)):
                self.blocks[i].bocos[j].family = otherGrid.blocks[i].bocos[j].family

    def overwriteBCs(self, bcFile):
        """Overwrite BCs with information given in the file"""

        f = open(bcFile, 'r')
        for line in f:
            if line.strip():
                aux = line.split()
                block = int(aux[0])-1
                face = aux[1]
                bctype = aux[2]
                family = aux[3]
                data = {}
                for i in range(4, len(aux), 2):
                    data[aux[i]] = float(aux[i+1])
                
                self.blocks[block].overwriteBCs(face, bctype, family, data)
        f.close()

    def autoOversetBC(self, sym):
        """This is essentially a simplified version of autoBC that flags all
        kMin faces as walls and all kMax faces as BCOverset"""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Next check for a wall-type boundary condition if
                    # we have a kMin face
                    if pointRanges[2, 0, i] == pointRanges[2, 1, i] == 1:
                        bocoType = BC['bcwallviscous']
                        famName = 'wall'
                    else:
                        # Must be a overset outer bound
                        bocoType = BC['bcoverset']
                        famName = 'overset'

                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))
 
        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def autoNearfieldBC(self, sym):
        """This is essentially a simplified version of autoBC that flags all
        boundaries as BCOverset except for possible symmetry planes."""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1

            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Flag as overset
                    bocoType = BC['bcoverset']
                    famName = 'overset'

                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))

        # Lastly rename the BCs to be consistent
        self.renameBCs()


    def autoFarfieldBC(self, sym):
        """This is essentially a simplified version of autoBC that flags all
        boundaries as BCOverset except for possible symmetry planes."""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Flag as overset
                    bocoType = BC['bcfarfield']
                    famName = 'far'

                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))

        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def double2D(self):
        """Doubles a mesh in the "2d" direction. Ie the direction with one
        cell"""
        for blk in self.blocks:
            blk.double2D()

    def simpleCart(self, dh, hExtra, nExtra, sym, mgcycle, outFile):
        """Generates a cartesian mesh around the provided grid"""

        # Get the bounds of each grid.
        xMin = 1e20*numpy.ones(3)
        xMax = -1.0*numpy.ones(3)

        for blk in self.blocks:
            tmp1 = numpy.min(blk.coords, axis=(0,1,2))
            tmp2 = numpy.max(blk.coords, axis=(0,1,2))
            for iDim in range(3):
                xMin[iDim] = min(xMin[iDim], tmp1[iDim])
                xMax[iDim] = max(xMax[iDim], tmp2[iDim])
        
        # Now determine how many nodes we need on the inside
        MGFact = 2**(mgcycle-1)
        N = numpy.zeros(3, 'intc')
        dx = numpy.zeros(3)
        r = numpy.zeros(3)
        Xcart = []  
        for iDim in range(3):
            n = int((xMax[iDim]-xMin[iDim])/dh)
            n = n//MGFact + 1
            N[iDim] = n*MGFact # Number of CELLS

            # Compute the *actual* dx's 
            dx[iDim] = (xMax[iDim]-xMin[iDim])/N[iDim]

            # Next we need to find the grid stretch ratios for each
            # direction to satify our requested extra distance. 
            r[iDim] = libcgns_utils.calcgridratio(nExtra, dx[iDim], hExtra)
            
            # Determine if this direction should have a sym plane:
            pos = True
            neg = True

            if sym == 'x' and iDim == 0:
                neg = False
            if sym == 'y' and iDim == 1:
                neg = False
            if sym == 'z' and iDim == 2:
                neg = False
                
            # Now fill up the cartesian direction
            n = N[iDim]
            iStart = 0
            if neg:
                n += nExtra
                iStart = nExtra

            if pos:
                n += nExtra

            # cordinates for this dimension
            x = numpy.zeros(n + 1)

            # First coordinate is at iStart:
            x[iStart] = xMin[iDim]

            # Add remainder of the uniform part:
            for i in range(N[iDim]):
                x[i+1+iStart] = x[i+iStart] + dx[iDim]

            # Add neg part if necessary:
            if neg:
                for i in range(nExtra):
                    x[iStart - 1 -i] = x[iStart - i] - r[iDim]*(
                        x[iStart -i +1] - x[iStart - i])
            if pos:
                iStart = iStart + N[iDim]
                for i in range(nExtra):
                    x[iStart + i + 1] = x[iStart + i] + r[iDim]*(
                        x[iStart + i] - x[iStart + i - 1])
            
            Xcart.append(x)
            
        # Allocate coordinates block
        shp = [Xcart[0].shape[0], Xcart[1].shape[0], Xcart[2].shape[0]]
        X = numpy.zeros((shp[0], shp[1], shp[2], 3))

        print ('Grid Dimensions:', shp)
        print ('Grid Ratios:', r)
        # Write grid coordinates
        Xx, Xy, Xz = numpy.meshgrid(Xcart[0], Xcart[1], Xcart[2], indexing='ij')
        X[:,:,:,0] = Xx
        X[:,:,:,1] = Xy
        X[:,:,:,2] = Xz

        # Open a new CGNS file and write if necessary:
        cg = libcgns_utils.openfile(outFile, CG_MODE_WRITE)

        # Write a Zone to it
        zoneID = libcgns_utils.writezone(cg, 'cartesian', shp)
        
        # Write mesh coordinates
        libcgns_utils.writecoordinates(cg, zoneID, X)
        
        # CLose file
        libcgns_utils.closefile(cg)

        return X, dx

    def simpleOCart(self, dh, hExtra, nExtra, sym, mgcycle, outFile):
        """Generates a cartesian mesh around the provided grid, surrounded by
        an O-Mesh"""

        # First run simpleCart with no extension:
        X, dx = self.simpleCart(dh, 0.0, 0, sym, mgcycle, outFile)
        
        # Pull out the patches. Note that we have to pay attention to
        # the symmetry and the ordering of the patches to make sure
        # that all the normals are pointing out. 
        patches = []
        patches.append(X[-1, :, :, :])
        patches.append(X[:, -1, :, :][::-1, :, :])
        patches.append(X[:, :, -1, :])
        if sym != 'x':
            patches.append(X[0, :, :, :][::-1, :, :])
        if sym != 'y':
            patches.append(X[:, 0, :, :])
        if sym != 'z':
            patches.append(X[:, :, 0, :][::-1, :, :])

        # Set up the generic input for pyHyp:
        hypOptions = {
            'patches':patches,
            'unattachedEdgesAreSymmetry':True,
            'outerFaceBC':'farField',
            'autoConnect':True,
            'BC':{},
            'N': nExtra,
            's0':numpy.average(dx),
            'marchDist':hExtra,
            'cmax':5,
        }

        # Run pyHyp
        from pyhyp import pyHyp
        hyp = pyHyp(options=hypOptions)
        hyp.run()
        dirpath = tempfile.mkdtemp()
        fName = os.path.join(dirpath, 'tmp.cgns')
        hyp.writeCGNS(fName)

        # Read the pyhyp mesh back in and add our additional "X" from above.
        grid = readGrid(fName)
        dims = X.shape[0:3]
        grid.addBlock(Block('interiorBlock', dims, X))
        grid.renameBlocks()
        grid.connect()
        grid.BCs = []
        grid.autoFarfieldBC(sym)
        grid.writeToCGNS(outFile)
            
        # Delete the temp file
        os.remove(fName)

    def cartesian(self, cartFile, outFile):
        """Generates a cartesian mesh around the provided grid"""

        # PARAMETERS
        inLayer = 2 # How many layers of the overset interpolation
                    # faces will be used for volume computation

        print ('Running cartesian grid generator')

        # Preallocate arrays
        extensions = numpy.zeros((2,3),order='F')
        nNodes = numpy.zeros(3,order='F')
        weightGR = numpy.zeros(3,order='F')
        numBins = numpy.zeros(3,order='F')

        # Read four lines of the cartesian specs file
        with open(cartFile, 'r') as f:
            lines = list(f)
        extensions[0,:] = lines[0].split()
        extensions[1,:] = lines[1].split()
        nNodes[:] = lines[2].split()
        weightGR[:] = lines[3].split()

        # Specify number of bins
        numBins[:] = 1 #The tangent law only works for single bin

        # Initialize bounding box coordinates using the first point of the first zone
        xBounds = numpy.zeros((2,3),order='F')
        xBounds[0,0] = self.blocks[0].coords[0,0,0,0] # Using the first point for initialization
        xBounds[1,0] = self.blocks[0].coords[0,0,0,0] # because I can't use 0
        xBounds[0,1] = self.blocks[0].coords[0,0,0,1]
        xBounds[1,1] = self.blocks[0].coords[0,0,0,1]
        xBounds[0,2] = self.blocks[0].coords[0,0,0,2]
        xBounds[1,2] = self.blocks[0].coords[0,0,0,2]
        binVolX = numpy.zeros(numBins[0], order='F') # Assign zeroes to all bins
        binVolY = numpy.zeros(numBins[1], order='F')
        binVolZ = numpy.zeros(numBins[2], order='F')
        binCellsX = numpy.zeros(numBins[0], order='F', dtype=int) # Initialize cells counter for each bin
        binCellsY = numpy.zeros(numBins[1], order='F', dtype=int)
        binCellsZ = numpy.zeros(numBins[2], order='F', dtype=int)

        # Loop over all blocks to find the bounding box coordinates
        for index in range(len(self.blocks)):
            # Loop over all BCs of this block
            for boco in self.blocks[index].bocos:
                # Check if we have an overset boundary condition
                if boco.type == BC['bcoverset']:
                    # Find overset BC face and select some inner layers to compute volume
                    r = boco.ptRange
                    if r[0][0] == r[0][1] == 1: #ilow detected
                        imin = 0
                        imax = min(0+inLayer,self.blocks[index].dims[0])
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[0][0] == r[0][1] == self.blocks[index].dims[0]: #ihigh detected
                        imin = max(self.blocks[index].dims[0]-inLayer, 0)
                        imax = self.blocks[index].dims[0]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == 1: #jlow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = 0
                        jmax = min(0+inLayer,self.blocks[index].dims[1])
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == self.blocks[index].dims[1]: #jhigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = max(self.blocks[index].dims[1]-inLayer, 0)
                        jmax = self.blocks[index].dims[1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[2][0] == r[2][1] == 1: #klow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = 0
                        kmax = min(0+inLayer,self.blocks[index].dims[2])
                    elif r[2][0] == r[2][1] == self.blocks[index].dims[2]: #khigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = max(self.blocks[index].dims[2]-inLayer, 0)
                        kmax = self.blocks[index].dims[2]
                    # Use the range to compute average volume
                    libcgns_utils.findbounds(self.blocks[index].coords[imin:imax, jmin:jmax, kmin:kmax, :], xBounds)

        # Loop over all blocks to find the bin volumes
        for index in range(len(self.blocks)):
            # Loop over all BCs of this block
            for boco in self.blocks[index].bocos:
                # Check if we have an overset boundary condition
                if boco.type == BC['bcoverset']:
                    # Find overset BC face and select some inner layers to compute volume
                    r = boco.ptRange
                    if r[0][0] == r[0][1] == 1: #ilow detected
                        imin = 0
                        imax = min(0+inLayer,self.blocks[index].dims[0])
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[0][0] == r[0][1] == self.blocks[index].dims[0]: #ihigh detected
                        imin = max(self.blocks[index].dims[0]-inLayer, 0)
                        imax = self.blocks[index].dims[0]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == 1: #jlow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = 0
                        jmax = min(0+inLayer,self.blocks[index].dims[1])
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == self.blocks[index].dims[1]: #jhigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = max(self.blocks[index].dims[1]-inLayer, 0)
                        jmax = self.blocks[index].dims[1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[2][0] == r[2][1] == 1: #klow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = 0
                        kmax = min(0+inLayer,self.blocks[index].dims[2])
                    elif r[2][0] == r[2][1] == self.blocks[index].dims[2]: #khigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = max(self.blocks[index].dims[2]-inLayer, 0)
                        kmax = self.blocks[index].dims[2]
                    # Use the range to compute average volume
                    libcgns_utils.computevolumes(self.blocks[index].coords[imin:imax, jmin:jmax, kmin:kmax, :], xBounds, \
                                                 binVolX, binVolY, binVolZ, binCellsX, binCellsY, binCellsZ)

        # DEFINE UNIDIMENSIONAL GRID GENERATION ROUTINES

        # Define tangent bunching law
        def tanDist(Sp1,Sp2,N):

            # This is the tangential spacing developed by Ney Secco
            # This bunching law is coarse at the ends an fine at the middle
            # of the interval, just like shown below:
            # |    |   |  | || |  |   |    |

            # Sp1: initial spacing (within the [0,1] interval)
            # Sp2: final spacing (within the [0,1] interval)
            # N: number of nodes
    
            # IMPORTS
            from numpy import tan, arange, pi
            from scipy.optimize import minimize
    
            # Convert number of nodes to number of cells, because I derived the equations using
            # N the as number of cells =P.
            N = N-1

            # Define objective function
            def func(P):
                # Split variables
                a = P[0]
                e = P[1]
                c = P[2]
                # Find b
                b = e - c
                # Equations
                Eq1 = a*(tan(b+c) - tan(c)) - 1
                Eq2 = a*(tan(b/N+c) - tan(c)) - Sp1
                Eq3 = a*(tan(b+c) - tan(b*(1-1/N)+c)) - Sp2
                # Cost function
                J = Eq1**2 + Eq2**2 + Eq3**2
                # Return
                return J

            # Define bounds for the problem
            a_bounds = [(0, None)]
            e_bounds = [(0, pi/2)]
            c_bounds = [(-pi/2 , 0)]
            bounds = a_bounds + e_bounds + c_bounds

            # Define initial guess
            a_start = 1.0
            e_start = pi/4
            c_start = -pi/4
            x_start = [a_start, e_start, c_start]

            # Optimize
            res = minimize(func, x_start, method='SLSQP', bounds=bounds, \
                           options={'maxiter':1000,'disp':False,'ftol':1e-12})

            # Split variables
            a = res.x[0]
            e = res.x[1]
            c = res.x[2]

            # Find other parameters
            b = e - c
            d = -a*tan(c)

            # Generate spacing
            index = arange(N+1)
            S = a*tan(b*index/N+c)+d
            
            # Force the extremes to 0 and 1 so that we always meet the bounds
            # (this is to avoid numerical issues with symmetry planes)
            S[0] = 0.0
            S[-1] = 1.0

            # Return spacing
            return S

        # Define function that optimizes bunching law to match grid resolution

        def generateGrid(xmin, xmax, extension1, extension2, nNodes, binVol, weightGR):

            # xmin: float -> position where the bounding box begins
            # xmax: float -> position where the bounding box ends
            # extension1: float > 0 -> ratio between the negative farfield distance and the bounding box length:
            #                          extension1 = (xmin-negative_farfield_position)/(xmax-xmin)
            # extension2: float > 0 -> ratio between the positive farfield distance and the bounding box length:
            #                          extension2 = (positive_farfield_position-xmax)/(xmax-xmin)
            # nNodes: integer > 0 -> Number of nodes along the edge
            # binVol: float > 0 -> Average volume of the bounding box cells (foreground mesh)
            # weightGR: 0 < float < 1 -> Weight used to balance growth ratio and cell volume during the optimization.
            #                            If weightGR = 0, the optimizer will not care about the growth ratios at the
            #                            farfield and will just try to match the bounding box resolution.
            #                            If weightGR = 1, the optimizer will not care about the bounding box resolution
            #                            and will just try to get an uniform growth ratio. This results in an uniform mesh.

            # IMPORTS
            from numpy import array, mean, zeros
            from scipy.optimize import minimize

            # Compute farfield coordinates
            x0 = xmin - (xmax-xmin)*extension1
            xf = xmax + (xmax-xmin)*extension2

            # Get number of bins and bin size
            nBins = len(binVol)
            dxBin = (xmax-xmin)/nBins

            # Get bin edges
            binEdge = binVol**(1./3.)

            # Define objective function
            def func(P):
                # Split variables
                Sp1 = P[0]
                Sp2 = P[1]

                # Generate grid coordinates with tangent bunching law
                S = tanDist(Sp1,Sp2,nNodes)

                # Rescale the interval
                S = x0 + S*(xf-x0)

                # Compute edge size of each cell
                E = S[1:]-S[:-1]

                # Initialize edge error
                edgeError = 0

                # Find cells that are inside each bin and check the edge difference
                for binIndex in range(nBins):
                    # Find bin interval
                    x0bin = xmin + dxBin*binIndex
                    xfbin = xmin + dxBin*(binIndex+1)
                    # Find cells that touch this interval and get their edges
                    bol = -(((S[:-1] < x0bin)*(S[1:] < x0bin))+((S[:-1] > xfbin)*(S[1:] > xfbin)))
                    bolEdges = E[bol]
                    #print bol
                    # Compute edge mismatch and increment variable
                    edgeError = edgeError + mean((bolEdges-binEdge[binIndex])**2)/2

                # Compute term regarding growing ratios at the ends
                if nNodes > 3:
                    growthRatio = ((S[1]-S[0])/(S[2]-S[1])-1.0)**2 + ((S[-1]-S[-2])/(S[-2]-S[-3])-1)**2
                else: #There's no way to define growth ratio when we have less than 3 cells
                    growthRatio = 0

                # Return objective function
                return (1-weightGR)*edgeError/mean(binEdge) + weightGR*growthRatio
                # Note that the edgeError is normalized so that the weighed average makes sense

            # Define initial guess based on uniform spacing
            Sp1_start = 1/(nNodes-1)
            Sp2_start = 1/(nNodes-1)
            x_start = array([Sp1_start, Sp2_start])

            # Optimize
            res = minimize(func, x_start, method='Nelder-Mead',
                           options={'maxiter':2000,'disp':True,'xtol':1e-8,'ftol':1e-8})

            # Split variables
            Sp1 = res.x[0]
            Sp2 = res.x[1]

            # Generate grid
            S = tanDist(Sp1,Sp2,nNodes)
            S = x0 + S*(xf-x0)

            # Return grid
            return S

        # Generate grid for each dimension
        Sx = generateGrid(xBounds[0,0], xBounds[1,0], extensions[0,0], extensions[1,0], nNodes[0], binVolX[0:1], weightGR[0])
        Sy = generateGrid(xBounds[0,1], xBounds[1,1], extensions[0,1], extensions[1,1], nNodes[1], binVolY[0:1], weightGR[1])
        Sz = generateGrid(xBounds[0,2], xBounds[1,2], extensions[0,2], extensions[1,2], nNodes[2], binVolZ[0:1], weightGR[2])

        # Compute growth ratios
        if nNodes[0] > 3:
            gx = max((Sx[1]-Sx[0])/(Sx[2]-Sx[1]), (Sx[-1]-Sx[-2])/(Sx[-2]-Sx[-3]))
        else:
            gx = None
        if nNodes[1] > 3:
            gy = max((Sy[1]-Sy[0])/(Sy[2]-Sy[1]), (Sy[-1]-Sy[-2])/(Sy[-2]-Sy[-3]))
        else:
            gy = None
        if nNodes[2] > 3:
            gz = max((Sz[1]-Sz[0])/(Sz[2]-Sz[1]), (Sz[-1]-Sz[-2])/(Sz[-2]-Sz[-3]))
        else:
            gz = None

        # Print growth ratios
        print ('')
        print ('Maximum growth ratios along each direction:')
        print ('X: ',gx)
        print ('Y: ',gy)
        print ('Z: ',gz)
        if max(gx,gy,gz) > 1.2:
            print ("You may bring weightGR closer to 1 to decrease ratios")
        print ('')

        # Allocate coordinates block
        X = numpy.zeros((nNodes[0],nNodes[1],nNodes[2],3))

        # Write grid coordinates
        Xx, Xy, Xz = numpy.meshgrid(Sx, Sy, Sz, indexing='ij')
        X[:,:,:,0] = Xx
        X[:,:,:,1] = Xy
        X[:,:,:,2] = Xz

        # Open a new CGNS file
        cg = libcgns_utils.openfile(outFile, CG_MODE_WRITE)

        # Write a Zone to it
        zoneID = libcgns_utils.writezone(cg, 'cartesian', nNodes)

        # Write mesh coordinates
        libcgns_utils.writecoordinates(cg, zoneID, X)

        # CLose file
        libcgns_utils.closefile(cg)

        # Print
        print ('Mesh successfully generated and stored in: '+outFile)

    def split(self, extraSplits):

        """Recursively propagate splits due to boundary conditions or
        B2B information"""

        # First generate a mapping between block name and its index:
        mapping = {}
        for iBlock in range(len(self.blocks)):
            mapping[self.blocks[iBlock].name] = iBlock

        for iBlock in range(len(self.blocks)):
            splits = []
            for boco in self.blocks[iBlock].bocos:
                splits.extend(getSplits(boco.ptRange))
            for b2b in self.blocks[iBlock].B2Bs:
                splits.extend(getSplits(b2b.ptRange))

            # Now just add the (unique) splits for this block: DON't
            # USE numpy.unique it doesn't actually work for tuples.
            newSplits = []
            for split in splits:
                if not split in newSplits:
                    newSplits.append(split)
            splits = newSplits

            for split in splits:
                self._addSplit(iBlock, split[0]+1, split[1], mapping)
                
        # And Add the extra splits:
        for split in extraSplits:
            self._addSplit(split[0]-1, split[1], split[2], mapping)

    def _addSplit(self, iBlock, iDim, index, mapping):
        """Recursive routine to add a split to block 'iBlock', on
        dimension 'iDim' at index 'index'. NOTE IDIM is 1 based!"""
        if index in self.blocks[iBlock].splits[iDim-1]:
            return # This is the main recursive return
        else:
            # Add the split and call any others we need
            self.blocks[iBlock].splits[iDim-1].append(index)
            self.blocks[iBlock].splits[iDim-1].sort()

            for b2b in self.blocks[iBlock].B2Bs:
                low = min(b2b.ptRange[iDim-1, :])
                high = max(b2b.ptRange[iDim-1, :])

                # Index must be fully contained:
                if index > low and index < high:
                    newBlock = mapping[b2b.donorName]
                    iDim_new = b2b.transform[iDim-1]
                    offset = index - low
                    abs_idim = abs(iDim_new)
                    donor_high = max(b2b.donorRange[abs_idim-1, :])
                    donor_low = min(b2b.donorRange[abs_idim-1, :])

                    if iDim_new >= 0:
                        index_new = donor_low + offset
                    else:
                        index_new = donor_high - offset

                    # Finally recursively call itself for the new
                    # block, dimension and index
                    self._addSplit(newBlock, abs_idim, index_new, mapping)
                            
    def connect(self):
        """Generate block-to-block connectivity information for a grid. It
        does not need to be face matched, only point matched"""
        isize = 0
        for i in range(len(self.blocks)):
            blk = self.blocks[i]
            isize += blk.dims[0]*blk.dims[1]*blk.dims[2]

        # Allocate space for all coordinates
        coords = numpy.zeros(isize*3)
        sizes = []
        istart = 0
        for i in range(len(self.blocks)):
            blk = self.blocks[i]
            iend = istart + blk.dims[0]*blk.dims[1]*blk.dims[2]
            coords[istart*3:3*iend] = blk.coords.flatten()
            sizes.append(blk.dims)
            istart = iend
        
        # Get our list of sizes
        sizes  = numpy.vstack(sizes)

        # Run the fortran code to generate all the connectivities
        libcgns_utils.computeconnectivity(coords, sizes.T)
        nPatches = libcgns_utils.getnpatches()
        types, pointRanges, myIDs, pointRangeDonors, \
            transforms, donorIDs, faceAvgs, faceNormals = \
            libcgns_utils.getpatchinfo(nPatches)
        libcgns_utils.deallocpatches()

        # Remove all existing B2B info
        for blk in self.blocks:
            blk.B2Bs = []

        for i in range(nPatches):
            blockID = myIDs[i] - 1
            
            if types[i] == 1: # B2B
                connectName = 'SF%d'%i
                donorName = self.blocks[donorIDs[i]-1].name
                
                self.blocks[blockID].B2Bs.append(B2B(
                    connectName, donorName, pointRanges[:, :, i], 
                    pointRangeDonors[:, :, i], transforms[:, i]))

        # Return most of the information we computed since other
        # routines (autobc for example) may need this.

        return types, pointRanges, myIDs, faceAvgs, faceNormals

    def autoBC(self, radius, sym, offset):
        """This function will try to generate boundary condition
        information for all patches that are not part of a
        block-to-block connection. If a surface is inside the sphere,
        it gets counted as a wall, if it is outside it is a farfield
        condition. If the surface is flat and a coordinate is zero, it
        gets treated as a symmetry plane."""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Next check for a wall-type boundary condition if
                    # the face avg is inside the sphere:

                    if numpy.linalg.norm(faceAvg[:, i] - offset) < radius:
                        bocoType = BC['bcwallviscous']
                        famName = 'wall'
                    else:
                        # Must be a farfield
                        bocoType = BC['bcfarfield']
                        famName = 'far'
                
                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))
 
        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def rebunch(self, spacing, extraCells, nStar):
        """Perform rebunching on offwall-directions. The user should
        be *VERY* careful with this function. It will *only* work for
        grids that that have 'O-type' topologies around the
        surface. This is typical of viscous grids. The main
        application is to rebunch nodes in the boundary layer to adapt
        an existing grid for a different reynolds number"""

        for blk in self.blocks:
            blk.rebunch(spacing, extraCells, nStar)
            blk.B2Bs = []
            blk.BCs = []
        self.connect()

    def randomize(self, seed):
        """Perform random reording of grid orientation and block numbers. This
        method destroys *ALL* boundary condition information. Grid
        connectivity is recomputed on the reorginized grid. Actual
        nodal locations remain precisely unchanged; only the grid
        ordering changes. Block handendness is not necessairly
        preserved.
        """
        numpy.random.seed(seed)
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []
            blk.randomize()

        # Finally reconnect
        self.connect()

    def reorder(self, intDigits):
        """
        When CGNSlib generates a CGNS file (when converting from a plot3d file, for instance),
        it does not add extra digits to the integers when naming zones. This becomes a problem
        when you have more than 10 zones because the ordering will be:
        Zone1, Zone11, Zone12, ..., Zone19, Zone2, Zone21, ...
        This method will add extra digits to the zone names to give the correct ordering.
        """
        
        # IMPORTS
        import re
        
        # Initialize list of names
        nameList = []

        # Loop over the blocks to add more significant digits to the last integer
        for blk in self.blocks:
            # Find last integer in the current name
            last_int = re.findall('\d+', blk.name)[-1]

            # Apply modifications only if we have found an integer
            if last_int:
                # Crop the integer from the name
                blk.name = blk.name[:-len(last_int)]
                # Add zeros to get the necessary number of digits
                last_int = last_int.zfill(intDigits)
                # Append integer with more significant digits back to the name
                blk.name = blk.name + last_int

            # Append the name to the names list
            nameList.append(blk.name)
        
        # Reorder blocks based on their new names
        self.blocks = [blk for (n,blk) in sorted(zip(nameList,self.blocks))]
        
    def symmZero(self, sym):
        """Zero nodes along axis 'sym'"""
        if sym == 'x':
            idir = 0
        elif sym == 'y':
            idir = 1
        elif sym == 'z':
            idir = 2
        for blk in self.blocks:
            blk.symmZero(idir)

    def translate(self, dx, dy, dz):
        for blk in self.blocks:
            blk.coords[:, :, :] += [dx, dy, dz]

class Block(object):
    """Class for storing information related to a single block
    structured zone"""
    
    def __init__(self, zoneName, dims, coords):
        self.name = zoneName.strip()
        self.dims = dims
        self.coords = coords
        self.bocos = []
        self.B2Bs = []
        self.splits = [[1, dims[0]], 
                       [1, dims[1]], 
                       [1, dims[2]]]
        self.bocoCounter = 0

    def addBoco(self, boco):
        """ A add a boundary condition to this block"""
        self.bocos.append(boco)
        
    def addB2B(self, b2b):
        """ A  block-2-block connection to this block"""
        self.B2Bs.append(b2b)

    def writeToCGNS(self, cg):
        """ Write all information in this block to the cg file handle"""

        zoneID = libcgns_utils.writezone(cg, self.name, self.dims)
        libcgns_utils.writecoordinates(cg, zoneID, self.coords)

        for boco in self.bocos:
            iBC = libcgns_utils.writebc(cg, zoneID, boco.name, boco.family, 
                                        boco.ptRange, boco.type)
            writeHeader = True
            for key in boco.data:
                libcgns_utils.writebcdata(cg, zoneID, boco.type, iBC, 
                                          key, boco.data[key], writeHeader)
                writeHeader = False

        for b2b in self.B2Bs:
            libcgns_utils.writeb2b(cg, zoneID, b2b.name, b2b.donorName,
                                   b2b.ptRange, b2b.donorRange,
                                   b2b.transform)

    def writeDimsPlot3d(self, f):
        """Write dimensions to a plot3d file"""
        f.write('%d %d %d\n'% (self.dims[0], self.dims[1], self.dims[2]))

    def writeCoordsPlot3d(self, f):
        """Write coordinates to plot3d file"""
        for iDim in range(3):
            self.coords[:, :, :, iDim].flatten(1).tofile(f, sep="\n", format='%20.15g')
            f.write('\n')
            
    def scale(self, scaleFact):
        """Scale the coordinates"""
        self.coords *= scaleFact

    def flip(self, axis):
        """Flip coordinates by plane defined by 'axis'"""
        if axis.lower() == 'x':
            index = 0
        elif axis.lower() == 'y':
            index = 1
        elif axis.lower() == 'z':
            index = 2
        self.coords[:, :, :, index] = -self.coords[:, :, :, index]

        # HOWEVER just doing this results in a left-handed block (if
        # the original block was right handed). So we have to also
        # reverse ONE of the indices 
        for k in range(self.dims[2]):
            for j in range(self.dims[1]):
                for idim in range(3):
                    self.coords[:, j, k, idim] = self.coords[::-1, j, k, idim]
        # AND we now have to flip the BC's on i-faces since they will
        # now be on the other side:
        for boco in self.bocos:
            if (boco.ptRange[0, 0] == boco.ptRange[0, 1] and 
                boco.ptRange[0, 0] == 1):
                boco.ptRange[0,0] = self.dims[0]
                boco.ptRange[0,1] = self.dims[0]
            elif (boco.ptRange[0, 0] == boco.ptRange[0, 1] and 
                  boco.ptRange[0, 0] == self.dims[0]):
                boco.ptRange[0,0] = 1
                boco.ptRange[0,1] = 1

    def coarsen(self):
        """Coarsen the block uniformly. We will update the boundary
        conditions and B2B if necessary"""
        self.coords = self.coords[0::2, 0::2, 0::2, :]
        self.dims[0] = self.coords.shape[0]
        self.dims[1] = self.coords.shape[1]
        self.dims[2] = self.coords.shape[2]
        for boco in self.bocos:
            boco.coarsen()
        for b2b in self.B2Bs:
            b2b.coarsen()

    def refine(self):
        """Refine the block uniformly. We will also update the
        boundary conditions and B2Bs if necessary"""
        self.coords = libcgns_utils.refine(self.coords)
        self.dims[0] = self.coords.shape[0]
        self.dims[1] = self.coords.shape[1]
        self.dims[2] = self.coords.shape[2]
        for boco in self.bocos:
            boco.refine()
        for b2b in self.B2Bs:
            b2b.refine()

    def section(self, iStart, iEnd, jStart, jEnd, kStart, kEnd):
        self.bocos = []
        self.B2Bs = []
        self.coords = self.coords[iStart-1:iEnd, jStart-1:jEnd, kStart-1:kEnd, :]
        self.dims[0] = self.coords.shape[0]
        self.dims[1] = self.coords.shape[1]
        self.dims[2] = self.coords.shape[2]
      
    def double2D(self):
        """Double in just the 2D direction"""
        # First find the 2D direction
        for dim_index in range(3):
            if self.dims[dim_index] == 2:
                # Increase the size of the 2D dimension
                new_dimensions = self.dims[:]
                new_dimensions[dim_index] = new_dimensions[dim_index] + 1
                newCoords = numpy.zeros((new_dimensions[0], new_dimensions[1], new_dimensions[2], 3))
                
                if dim_index == 0:
                    for i in range(self.dims[1]):
                        for j in range(self.dims[2]):
                            newCoords[0, i, j, :] = self.coords[0, i, j, :]
                            newCoords[2, i, j, :] = self.coords[1, i, j, :]
                            newCoords[1, i, j, :] = 0.5*(newCoords[0, i, j, :] + 
                                                         newCoords[2, i, j, :])
                elif dim_index == 1:
                    for i in range(self.dims[0]):
                        for j in range(self.dims[2]):
                            newCoords[i, 0, j, :] = self.coords[i, 0, j, :]
                            newCoords[i, 2, j, :] = self.coords[i, 1, j, :]
                            newCoords[i, 1, j, :] = 0.5*(newCoords[i, 0, j, :] + 
                                                         newCoords[i, 2, j, :])
                elif dim_index == 2:
                    for i in range(self.dims[0]):
                        for j in range(self.dims[1]):
                            newCoords[i, j, 0, :] = self.coords[i, j, 0, :]
                            newCoords[i, j, 2, :] = self.coords[i, j, 1, :]
                            newCoords[i, j, 1, :] = 0.5*(newCoords[i, j, 0, :] + 
                                                         newCoords[i, j, 2, :])


                for boco in self.bocos:
                    for j in range(2):
                        if boco.ptRange[dim_index, j] == 2:
                            boco.ptRange[dim_index, j] = 3
                for b2b in self.B2Bs:
                    for j in range(2):
                        if b2b.ptRange[dim_index, j] == 2:
                            b2b.ptRange[dim_index, j] = 3
                        if b2b.donorRange[dim_index, j] == 2:
                            b2b.donorRange[dim_index, j] = 3

                # Replace previous coordinates
                self.coords = newCoords
                self.dims = new_dimensions[:]

    def getSplitBlocks(self):
        """Return a list of blocks that have been split according to
        the self.splits array. This is used for the 'split' operation
        as well as for the 'divide' operation. Boundary information is
        kept but connectivity information is removed"""
        blkList = []
        s = self.splits # For cleaner code below

        for i in range(len(s[0])-1):
            for j in range(len(s[1])-1):
                for k in range(len(s[2])-1):
                    newCoords = self.coords[
                        s[0][i]-1:s[0][i+1],
                        s[1][j]-1:s[1][j+1],
                        s[2][k]-1:s[2][k+1], :].copy()

                    dims = [newCoords.shape[0], newCoords.shape[1],
                            newCoords.shape[2]]
                    blk = Block('dummy', dims, newCoords)

                    # Loop over the 6 faces and determine what BC they
                    # came from:

                    for boco in self.bocos:
                        # iLow
                        chkRange = [[s[0][i], s[0][i]],
                                    [s[1][j], s[1][j+1]],
                                    [s[2][k], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, 1], [1, dims[1]], [1, dims[2]]],
                                 boco.family))

                        # iHigh
                        chkRange = [[s[0][i+1], s[0][i+1]],
                                    [s[1][j],   s[1][j+1]],
                                    [s[2][k],   s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[dims[0], dims[0]], [1, dims[1]], [1, dims[2]]],
                                boco.family))

                        # jLow
                        chkRange = [[s[0][i], s[0][i+1]],
                                    [s[1][j], s[1][j]],
                                    [s[2][k], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, 1], [1, dims[2]]],
                                 boco.family))

                        # jHigh
                        chkRange = [[s[0][i  ], s[0][i+1]],
                                    [s[1][j+1], s[1][j+1]],
                                    [s[2][k]  , s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [dims[1], dims[1]], [1, dims[2]]],
                                boco.family))

                        # kLow
                        chkRange = [[s[0][i], s[0][i+1]],
                                    [s[1][j], s[1][j+1]],
                                    [s[2][k], s[2][k]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, dims[1]], [1, 1]],
                                 boco.family))

                        # kHigh
                        chkRange = [[s[0][i]  , s[0][i+1]],
                                    [s[1][j]  , s[1][j+1]],
                                    [s[2][k+1], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, dims[1]], [dims[2], dims[2]]],
                                 boco.family))

                    blkList.append(blk)
        return blkList
    
    def divide(self):
        """Return a list of 8 blocks split derivied from the current
        block. Boundary condition information is kept, but
        connectivity information is removed"""

        # Just add the splits and run getSplitBlocks
        for iDim in range(3):
            self.splits[iDim].append((self.dims[iDim]-1)//2 + 1)
            self.splits[iDim].sort()
            
        return self.getSplitBlocks()
    
    def removeSymBCs(self):
        """Remove any sym BC's there may be"""
        self.bocos = [boco for boco in self.bocos 
                      if not boco.type == BC['bcsymmetryplane']]

    def extractWallSurfaces(self):
        """Return patches for any surfaces that have BCViscous on them"""
        patches = []
        for boco in self.bocos:
            if isWall(boco.type):
                ptRange = boco.ptRange - 1 # Convert to python ordering
                patches.append(self.coords[
                    ptRange[0, 0]:ptRange[0, 1]+1, 
                    ptRange[1, 0]:ptRange[1, 1]+1, 
                    ptRange[2, 0]:ptRange[2, 1]+1, :].squeeze())
                # Make sure the patch is correctly orientated since we
                # might have left-handed faces. Essentially we have to
                # flip an index on any "high" boundary condition:

                if ((ptRange[0, 0] == ptRange[0, 1] and 
                     ptRange[0, 0]+1 == self.dims[0]) or 
                    (ptRange[1, 0] == ptRange[1, 1] and 
                     ptRange[1, 0]+1 == 1) or 
                    (ptRange[2, 0] == ptRange[2, 1] and 
                     ptRange[2, 0]+1 == self.dims[2])):
                    patches[-1] = patches[-1][::-1, :, :]

        return patches

    def overwriteFamily(self, faceStr, family):
        """Possibly overwrite the family in the bocos if possible"""
        for boco in self.bocos:
            r = boco.ptRange
            match = (
                (r[0][0] == r[0][1] == 1 and faceStr == 'ilow') or
                (r[0][0] == r[0][1] == self.dims[0] and faceStr == 'ihigh') or
                (r[1][0] == r[1][1] == 1 and faceStr == 'jlow') or
                (r[1][0] == r[1][1] == self.dims[1] and faceStr == 'jhigh') or
                (r[2][0] == r[2][1] == 1 and faceStr == 'klow') or
                (r[2][0] == r[2][1] == self.dims[2] and faceStr == 'khigh'))

            if match:
                boco.family = family

    def overwriteBCs(self, faceStr, bcType, family, data):
        """Find any BCs on this face and toast them. Note that we *ONLY ALLOW
        ONE BC per face*
        """
        
        # Check for existing boco and pop if necessary
        pop_list = []
        for index in range(len(self.bocos)):
            boco = self.bocos[index]
            r = boco.ptRange
            match = (
                (r[0][0] == r[0][1] == 1 and faceStr == 'ilow') or
                (r[0][0] == r[0][1] == self.dims[0] and faceStr == 'ihigh') or
                (r[1][0] == r[1][1] == 1 and faceStr == 'jlow') or
                (r[1][0] == r[1][1] == self.dims[1] and faceStr == 'jhigh') or
                (r[2][0] == r[2][1] == 1 and faceStr == 'klow') or
                (r[2][0] == r[2][1] == self.dims[2] and faceStr == 'khigh'))

            if match:
                pop_list = pop_list + [index]

        # Pop all bcs in the face
        pop_list.reverse() # We have to remove the hogher indices first
        for index in pop_list:
            self.bocos.pop(index)

        d = self.dims
        faceStr = faceStr.lower()
        if faceStr == 'ilow':
            ptRange = [[1, 1, 1], [1, d[1], d[2]]]
        elif faceStr == 'ihigh':
            ptRange = [[d[0], 1, 1], [d[0], d[1], d[2]]]
        elif faceStr == 'jlow':
            ptRange = [[1, 1, 1], [d[0], 1, d[2]]]
        elif faceStr == 'jhigh':
            ptRange = [[1, d[1], 1], [d[0], d[1], d[2]]]
        elif faceStr == 'klow':
            ptRange = [[1, 1, 1], [d[0], d[1], 1]]
        elif faceStr == 'khigh':
            ptRange = [[1, 1, d[2]], [d[0], d[1], d[2]]]
        ptRange = numpy.array(ptRange).T
        newBoco = Boco("boco_%d"%self.bocoCounter, BC[bcType.lower()], 
                       ptRange, family, data)
        self.bocoCounter += 1
        self.bocos.append(newBoco)


    def rebunch(self, spacing, extraCells, nStar):
        """Perform rebunching for this block"""
        from pyspline import Curve

        # ********* WARNING THIS HARD CODED TO K-MIN PLANES *********
        self.dims[2] += extraCells
        if nStar == -1:
            nStar = self.dims[2]
            
        newNodes = numpy.zeros((self.dims[0], self.dims[1], self.dims[2] ,3))
        for i in range(self.dims[0]):
            for j in range(self.dims[1]):

                xx = self.coords[i, j, :, :]
                c = Curve(X=xx, localInterp=True)
                # First get the distance off-wall:
                d = numpy.linalg.norm(self.coords[i, j, 0, :] -
                                      self.coords[i, j, 1, :])
        
                # This is the segment of S we are dealing with:
                sSegment = c.s[0:nStar]

                # Compute the new S0
                s0 = (spacing / d)*c.s[1]
                # Get the newS. 
                newS = getS(len(sSegment) + extraCells + 1, s0, sSegment[-1])
                # The final 's' for evaluation
                newS = numpy.hstack([newS, c.s[nStar+1:]])
                newNodes[i, j, :, :] = c(newS)

        self.coords = newNodes

    def randomize(self):
        """Randomly reorder the indices in the block. No attempt is made to
        change BCs or B2Bs since these should be deleted already
        """

        if numpy.random.random() > 0.5:
            # We will flip the i-index
            for k in range(self.dims[2]):
                for j in range(self.dims[1]):
                    for idim in range(3):
                        self.coords[:, j, k, idim] = self.coords[::-1, j, k, idim]

        if numpy.random.random() > 0.5:
            # We will flip the j-index
            for k in range(self.dims[2]):
                for i in range(self.dims[0]):
                    for idim in range(3):
                        self.coords[i, :, k, idim] = self.coords[i, ::-1, k, idim]

        if numpy.random.random() > 0.5:
            # We will flip the k-index
            for j in range(self.dims[1]):
                for i in range(self.dims[0]):
                    for idim in range(3):
                        self.coords[i, j, :, idim] = self.coords[i, j, ::-1, idim]
        
        # So that filps the order of the axis. We can also perform
        # axis swapping. 
        if numpy.random.random() > 0.5:
            # Swap X and Y axis
            newCoords = numpy.zeros((self.dims[1], self.dims[0], self.dims[2], 3))
            for k in range(self.dims[2]):
                for idim in range(3):
                    newCoords[:, :, k, idim] = numpy.rot90(self.coords[:, :, k, idim].copy())

            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()

        if numpy.random.random() > 0.5:
            # Swap Z and X axis
            newCoords = numpy.zeros((self.dims[2], self.dims[1], self.dims[0], 3))
            for j in range(self.dims[1]):
                for idim in range(3):
                    newCoords[:, j, :, idim] = numpy.rot90(self.coords[:, j, :, idim])

            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()
            
        if numpy.random.random() > 0.5:
            # Swap Y and Z axis
            newCoords = numpy.zeros((self.dims[0], self.dims[2], self.dims[1], 3))
            for i in range(self.dims[0]):
                for idim in range(3):
                    newCoords[i, :, :, idim] = numpy.rot90(self.coords[i, :, :, idim])
                
            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()

    def symmZero(self, idir):
        for bc in self.bocos:
            if bc.type == BC['bcsymmetryplane']:
                # 'r' is the range. We need to subtract off -1 from
                # the low end since it was in fortran 1-based ordering
                r = bc.ptRange.copy()
                self.coords[r[0,0]-1:r[0,1], 
                            r[1,0]-1:r[1,1], 
                            r[2,0]-1:r[2,1], idir] = 0.0

    def getFaceCoords(self, blockID):
        """Return the list of coordinates on the face as well as its index info"""

        il = self.dims[0]
        jl = self.dims[1]
        kl = self.dims[2]
        nFace = 2*(  (il-1)*(jl-1) + (il-1)*(kl-1) + (jl-1)*(kl-1))

        return libcgns_utils.computefacecoords(self.coords, nFace, blockID)
      
class Boco(object):

    """Class for storing information related to a boundary condition"""
    def __init__(self, bocoName, bocoType, ptRange, family, bcData=None):
        self.name = bocoName.strip()
        self.type = bocoType
        self.ptRange = ptRange
        self.data = {}

        if family is None or family.strip() == '':
            self.family = 'default'
        else:
            self.family = family

    def coarsen(self):
        """Coarsen the range of the BC"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)//2 + 1

    def refine(self):
        """refine the range of the BC"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)*2 + 1


class B2B(object):
    """Class for storing information related to a Block-to-block or
    (1to1 in cgns speak) connection"""
    def __init__(self, connectName, donorName, ptRange, donorRange, transform):
        self.name = connectName.strip()
        self.donorName = donorName.strip()
        self.ptRange = ptRange
        self.donorRange = donorRange
        self.transform = transform

    def coarsen(self):
        """Coarsen the range of the B2B"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)//2 + 1
                self.donorRange[i, j] = (self.donorRange[i, j]-1)//2 + 1
    def refine(self):
        """refine the range of the B2B"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)*2 + 1
                self.donorRange[i, j] = (self.donorRange[i, j]-1)*2 + 1


# ----------------------------------------
# These are miscellaneous helper functions
# ----------------------------------------
def isWall(bc):
    """Determine if a bc is a wall-type boundary condition"""
    if (bc == BC['bcwall'] or 
        bc == BC['bcwallinviscid'] or 
        bc == BC['bcwallviscous'] or 
        bc == BC['bcwallviscousheatflux'] or 
        bc == BC['bcwallviscousisothermal']):
        return True
    else:
        return False

def getS(N, s0, S):
    """Determine the new set of parameters that geometrically fit N
    nodes with the last distance S"""
    
    # function 'f' is 1 - s0*(1-r^n)/(1-r), s0 is initial ratio and r
    # is the grid ratio.

    M = N-1
    # Bisection search:
    a = 1.0 + 1e-8
    b = 4.0

    def f(r):
        s = numpy.zeros(N)
        s[1]= s0
        for i in range(2, N):
            s[i] = s[i-1] + r*(s[i-1] - s[i-2])

        return s[-1]

    fa = S - f(a)
    fb = S - f(b)

    for i in range(100):
        c = 0.5*(a + b)
        ff = S - f(c)
        if abs(ff) < 1e-6:
            break
     
        if ff * fa > 0:
            a = c
        else:
            b = c
    s = numpy.zeros(N)
    s[1] = s0
  
    for i in range(2, N):
        s[i] = s[i-1] + c*(s[i-1] - s[i-2])

    return s
  
def getSplits(ptRange):
    """Return info required to split this face to make it face
    matched"""
    if ptRange[0][0] == ptRange[0][1]:
        splits = [(1, ptRange[1][0]), 
                  (1, ptRange[1][1]), 
                  (2, ptRange[2][0]), 
                  (2, ptRange[2][1])]
    elif ptRange[1][0] == ptRange[1][1]:
        splits = [(0, ptRange[0][0]), 
                  (0, ptRange[0][1]), 
                  (2, ptRange[2][0]), 
                  (2, ptRange[2][1])]
    elif ptRange[2][0] == ptRange[2][1]:
        splits = [(0, ptRange[0][0]), 
                  (0, ptRange[0][1]), 
                  (1, ptRange[1][0]), 
                  (1, ptRange[1][1])]
    return splits

def generalizedCoordDir(iFace):
    """Not really sure how this works..."""
    if iFace in [0, 1]:
        return [0, 1, 2]
    elif iFace in [2, 3]:
        return [1, 2, 0]
    elif iFace in [4, 5]:
        return [0, 2, 1]

def isodd(num):
    """check if a number is odd"""
    return num & 1 and True or False

def getPointRange(iFace, dims):
    """Return the correct point range for face iFace on a block with
    dimensions given in dims"""
    il = dims[0]
    jl = dims[1]
    kl = dims[2]
    if iFace == 0:
        return [[1, il], [1, jl], [1, 1]]
    elif iFace == 1:
        return [[1, il], [1, jl], [kl, kl]]
    elif iFace == 2:
        return [[1, 1], [1, jl], [1, kl]]
    elif iFace == 3:
        return [[il, il], [1, jl], [1, kl]]
    elif iFace == 4:
        return [[1, il], [1, 1], [1, kl]]
    elif iFace == 5:
        return [[1, il], [jl, jl], [1, kl]]

def inRange(ptRange, chkRange):
    """Determine if 'chkRange' fully overlaps with 'ptRange'"""
    val = True
    for iDim in range(3):
        if not (chkRange[iDim][0] >= ptRange[iDim][0] and 
                chkRange[iDim][1] <= ptRange[iDim][1]):
            val = False

    return val
             
# def normal_direction(iFace1, iFace2):
#     """Normal direction is positive if iFace1 and iFace two are of
#     opposite oddity, even if they are the same oddity"""
#     isOdd1 = isodd(iFace1)
#     isOdd2 = isodd(iFace2)

#     if isOdd1 is True and isOdd2 is True:
#         return -1
#     if isOdd1 is False and isOdd2 is False:
#         return -1

#     # otherwise:
#     return 1

# -----------------------------------------------------------------
# These functions perform operations that return new 'Grid' objects
# -----------------------------------------------------------------
def readGrid(fileName):
    """Internal routine to return a 'grid' object that contains all
    the information that is in the file 'fileName'"""

    inFile = libcgns_utils.openfile(fileName, CG_MODE_READ)
    cellDim = libcgns_utils.getgriddimension(inFile)
    nBlock = libcgns_utils.getnblocks(inFile)
    newGrid = Grid()
    
    for iBlock in range(1, nBlock+1):
        zoneName, dims, nBoco, nB2B = libcgns_utils.getblockinfo(inFile, iBlock)

        if cellDim == 2:
            dims[2] = 1
        coords = libcgns_utils.getcoordinates(inFile, iBlock,
                                              dims[0], dims[1], dims[2])
        blk = Block(zoneName, dims, coords)

        for iBoco in range(1, nBoco+1):
            bocoName, bocoType, ptRange, family = libcgns_utils.getbcinfo(
                inFile, iBlock, iBoco)
            blk.addBoco(Boco(bocoName, bocoType, ptRange, family))
        for iB2B in range(1, nB2B+1):
            connectName, donorName, ptRange, donorRange, transform = \
                         libcgns_utils.getb2binfo(inFile, iBlock, iB2B)
            blk.addB2B(B2B(connectName, donorName, ptRange, donorRange,
                           transform))
       
        newGrid.addBlock(blk)

    libcgns_utils.closefile(inFile)

    return newGrid

def mirrorGrid(grid, axis):
    """Method that takes a grid and mirrors about the axis. Boundary
    condition information is retained if possible"""

    # First make sure the grid is face matched:
    grid.split([])

    # Now copy original blocks
    newGrid = Grid()
    for blk in grid.blocks:
        blk.removeSymBCs()
        blk.B2Bs = []
        newGrid.addBlock(blk)

        mirrorBlk = copy.deepcopy(blk)
        mirrorBlk.flip(axis)
        newGrid.addBlock(mirrorBlk)

    # Now rename the blocks and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def divideGrid(grid):
    """Method that takes a grid and generates a new grid with 8 times
    as many blocks"""
    newGrid = Grid()
    for blk in grid.blocks:
        newBlks = blk.divide()
        for nblk in newBlks:
            newGrid.addBlock(nblk)

    # Now rename the blocks and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def splitGrid(grid, splitFile):
    """Method that takes a grid and propagates any splits using
    connectivity information. This is a rewrite of the original
    Fortran implementation that is quite a bit simpler due to Python"""
    # Split the current grid
    extraSplits = []
    if splitFile is not None:
        f = open(splitFile,'r')
        for line in f:
            aux = line.split()
            extraSplits.append([int(aux[0]), int(aux[1]), int(aux[2])])
        f.close()
    grid.split(extraSplits=extraSplits)

    # New grid
    newGrid = Grid()
    for blk in grid.blocks:
        newBlks = blk.getSplitBlocks()
        for nblk in newBlks:
            newGrid.addBlock(nblk)

    # # Now rename the blocks, bcs and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def mergeGrid(grid):
    """Method that that takes a grid with block to block connections and
    merges as many blocks as possible, reducing the total number of
    blocks in the mesh"""
    
    def fullFace(blk, ptRange):

        # Face size of the patch:
        fSize = abs(ptRange[:, 1] - ptRange[:, 0])
        
        fullFace = True
        for i in range(3):
            if fSize[i] != 0:
                if fSize[i] != blk.dims[i]-1:
                    fullFace = False

        return fullFace

    def faceID(ptRange, blk):
        if ptRange[0, 0] == ptRange[0, 1] == 1:
            faceID = -1
        elif ptRange[0, 0] == ptRange[0, 1] == blk.dims[0]:
            faceID = 1

        elif ptRange[1, 0] == ptRange[1, 1] == 1:
            faceID = -2
        elif ptRange[1, 0] == ptRange[1, 1] == blk.dims[1]:
            faceID = 2

        elif ptRange[2, 0] == ptRange[2, 1] == 1:
            faceID = -3
        elif ptRange[2, 0] == ptRange[2, 1] == blk.dims[2]:
            faceID = 3

        return faceID
    
    # Outer Iterative Loop
    cont = True
    iteration = 0
    while cont:

        # First create a mapping of the blocks from the name to the index
        zoneMap = {}

        for i in range(len(grid.blocks)):
            blk = grid.blocks[i]
            zoneMap[blk.name] = i

        blockUsed = numpy.zeros(len(grid.blocks), 'intc')
        newBlocks = []
        # Loop over each block:
        for i in range(len(grid.blocks)):
            blk = grid.blocks[i]

            # We haven't used this block yet:
            if blockUsed[i] == 0:

                # Loop over the B2B of this block:
                for b2b in blk.B2Bs:
                    otherIndex = zoneMap[b2b.donorName]
                    otherBlk = grid.blocks[otherIndex]
                    otherRange = b2b.donorRange

                    # Determine if this B2B is a full patch on my block
                    # *and* the other block
                    if (fullFace(blk, b2b.ptRange) and
                        fullFace(otherBlk, b2b.donorRange) and 
                        blockUsed[otherIndex] == 0 and 
                        i != otherIndex):
                        
                        print ('Merging:', i+1, otherIndex+1)

                        # Great! These block match. Let's make the new
                        # block 
                        
                        # Transform describes how the current block,
                        # blk, is related to the other block, otherBlk
                        transform = b2b.transform

                        # We need to determine which face we are
                        # dealing with (iLow, iHigh, etc) on each block

                        face = faceID(b2b.ptRange, blk)

                        dims = blk.dims.copy()
                        dims[abs(face)-1] += otherBlk.dims[abs(transform[abs(face)-1])-1] - 1
                        newCoords = numpy.zeros((dims[0], dims[1], dims[2], 3))

                        # Now transform the other coordinates to make
                        # them conform with the existing
                        # block. Essentially what we need to do
                        # perform a series of operations to convert
                        # the transfrom matrix back to [1, 2, 3],
                        # which means the block completely line up.
                        otherCoords = otherBlk.coords
                        
                        tmp = abs(transform)
                        # Now swap the axes until we get 1,2,3. There
                        # are only 6 cases, so just do them individually
                        if tmp[0] == 1 and tmp[1] == 2 and tmp[2] == 3:
                            # Nothing to do:
                            pass
                        elif tmp[0] == 1 and tmp[1] == 3 and tmp[2] == 2:
                            otherCoords = numpy.swapaxes(otherCoords, 2, 1)

                        elif tmp[0] == 2 and tmp[1] == 1 and tmp[2] == 3:
                            otherCoords = numpy.swapaxes(otherCoords, 0, 1)

                        elif tmp[0] == 2 and tmp[1] == 3 and tmp[2] == 1:
                            otherCoords = numpy.swapaxes(otherCoords, 0, 1)
                            otherCoords = numpy.swapaxes(otherCoords, 1, 2)

                        elif tmp[0] == 3 and tmp[1] == 1 and tmp[2] == 2:
                            otherCoords = numpy.swapaxes(otherCoords, 0, 2)
                            otherCoords = numpy.swapaxes(otherCoords, 1, 2)

                        elif tmp[0] == 3 and tmp[1] == 2 and tmp[2] == 1:
                            otherCoords = numpy.swapaxes(otherCoords, 2, 0)
                            
                        # This flips any axis not in the right order
                        if transform[0] < 0:
                            otherCoords = otherCoords[::-1, :, :, :]
                        if transform[1] < 0:
                            otherCoords = otherCoords[:, ::-1, :, :]                            
                        if transform[2] < 0:
                            otherCoords = otherCoords[:, :, ::-1, :]   

                        if face > 0:
                            # blk then otherBlk
                            if face == 1:
                                newCoords[0:blk.dims[0], :, :, :] = blk.coords
                                newCoords[blk.dims[0]-1:, :, :, :] = otherCoords

                            elif face == 2:
                                newCoords[:, 0:blk.dims[1], :, :] = blk.coords
                                newCoords[:, blk.dims[1]-1:, :, :] = otherCoords

                            elif face == 3:
                                newCoords[:, :, 0:blk.dims[2], :] = blk.coords
                                newCoords[:, :, blk.dims[2]-1:, :] = otherCoords

                        else:
                            # otherBlk then blk
                            if face == -1:
                                newCoords[0:dims[0]-blk.dims[0]+1, :, :, :] = otherCoords
                                newCoords[dims[0]-blk.dims[0]:, :, :] = blk.coords

                            elif face == -2:
                                newCoords[:, 0:dims[1]-blk.dims[1]+1, :, :] = otherCoords
                                newCoords[:, dims[1]-blk.dims[1]:, :, :] = blk.coords

                            elif face == -3:
                                newCoords[:, :, 0:dims[2]-blk.dims[2]+1, :] = otherCoords
                                newCoords[:, :, dims[2]-blk.dims[2]:, :] = blk.coords


                        # Create the new block
                        newBlk = Block('doesNotMatter', dims, newCoords)
                        
                        # Now deal with the boundary conditions. These
                        # need to be corrected depending on how the
                        # blocks get added.
                        offset = numpy.zeros(3, 'intc')
                        if face  == 1:
                            offset[0] = blk.dims[0] - 1
                        elif face == 2:
                            offset[1] = blk.dims[1] - 1
                        elif face == 3:
                            offset[2] = blk.dims[2] - 1
                        elif face == -1:
                            offset[0] = dims[0] - blk.dims[0]
                        elif face == -2:
                            offset[1] = dims[1] - blk.dims[1]
                        elif face == -3:
                            offset[2] = dims[2] - blk.dims[2]
                        
                        # Add all the bocos from the first block:
                        for boco in blk.bocos:
                            if face > 0:
                                # blk then otherBlk. BCs go in as is:
                                pass
                            else:
                                # BCs have to offset:
                                boco.ptRange[:, 0] += offset
                                boco.ptRange[:, 1] += offset

                            newBlk.addBoco(boco)

                        # Add all the bocos from the second
                        # block. This is tricky since we need to
                        # offset and potentially reorient them .
                        for boco in otherBlk.bocos:

                            tmp = boco.ptRange.copy()
                            if face > 0:
                                # blk then otherBlk. BCs need to be increemented by offset.
                                for idim in range(3):
                                    jdim = transform[idim]

                                    if jdim > 0:
                                        # Other block dim +ve, (ie in the same direction)
                                        boco.ptRange[idim, 0] =  offset[idim] + tmp[jdim-1, 0]
                                        boco.ptRange[idim, 1] =  offset[idim] + tmp[jdim-1, 1]
                                    else:
                                        # Other block dim -ve, (ie in the opposite direction)
                                        jdim = -jdim
                                        boco.ptRange[idim, 0] = offset[idim] + otherBlk.dims[jdim-1] - tmp[jdim-1, 1] + 1
                                        boco.ptRange[idim, 1] = offset[idim] + otherBlk.dims[jdim-1] - tmp[jdim-1, 0] + 1

                            else:
                                # otherBlk then blk. BCs need to be transformed only
                                for idim in range(3):
                                    jdim = transform[idim]

                                    if jdim > 0:
                                        # Other block dim +ve, (ie in the same direction)
                                        boco.ptRange[idim, 0] = tmp[jdim-1, 0]
                                        boco.ptRange[idim, 1] = tmp[jdim-1, 1]
                                    else:
                                        # Other block dim -ve, (ie in the opposite direction)
                                        jdim = -jdim
                                        boco.ptRange[idim, 0] = otherBlk.dims[jdim-1] - tmp[jdim-1, 1] + 1
                                        boco.ptRange[idim, 1] = otherBlk.dims[jdim-1] - tmp[jdim-1, 0] + 1

                            newBlk.addBoco(boco)

                        # Add the new block to the list
                        newBlocks.append(newBlk)

                        # Flag the two existing blocks as deleted
                        blockUsed[i] = 1
                        blockUsed[otherIndex] = 1

                        # We can't do anything else on this block so skip the rest of the b2b loop
                        break

                    # end if (matching)
                # end for (b2b loop)
            # end if (used check)
        # end for (block loop)

        if len(newBlocks) == 0:
            cont = False
            
        # Now loop back through the grids appending the blocks we
        # haven't used to "newBlocks"
        for i in range(len(grid.blocks)):
            if blockUsed[i] == 0:
                newBlocks.append(grid.blocks[i])

        # Set the new blocks
        grid.blocks = newBlocks
        print ("New number of blocks:", len(grid.blocks))

        # Rename the blocks and remove any B2B info since it will all
        # be recomputed:
        grid.renameBlocks()
        grid.B2Bs = []
        grid.connect()
        iteration +=1
    # end for (outer loop)

    return grid

def combineGrids(grids):

    """Method that takes in a list of grids and returns a new grid object
    containing all zones from each grid. The blocks are renamed as
    there could (almost most certainly) be conflicts between the zone
    names in the different grids. This also means that the block to
    block connectivities need to be updated based on the new zone names
    """

    # First determine the total number of blocks
    nBlock = 0
    newGrid = Grid()

    for grid in grids:

        # Mapping of the old names to the new names
        zoneMap = {}

        for blk in grid.blocks:
            nBlock += 1
            newName = 'domain.%5.5d'% nBlock
            zoneMap[blk.name] = newName
            blk.name = newName

        # Now loop back over the blocks, replacing the donorName using
        # the map we defined above
        for blk in grid.blocks:
            for b2b in blk.B2Bs:
                b2b.donorName = zoneMap[b2b.donorName]
                
        # Now add the new processed blocks to our newgrid
        newGrid.blocks.extend(grid.blocks)

    return newGrid

def explodeGrid(grid,kMin=False):
    """Method that takes one multiblock grid and returns a list of grids, each
    one containing a single block of the original multiblock grid
    """

    # Reduce block size if just Kmin face is needed
    if kMin:
        for blk in grid.blocks:
            blk.dims[2] = 1
            blk.coords = blk.coords[:, :, 0:1, :]

    # Initialize list of single block grids
    gridList = []

    # Add one block to each grid
    for blk in grid.blocks:
        # Initialize new grid
        newGrid = Grid()
        # Add a single block to this grid
        newGrid.addBlock(blk)
        # Now rename the blocks, bcs and redo-connectivity, only if we have full mesh
        if kMin is False:
            newGrid.renameBlocks()
            newGrid.renameBCs()
            newGrid.connect()
        # Append this new grid to the grids list
        gridList.append(newGrid)

    # return list of grids
    return gridList


# -------------------------------------------
#         Selection of the task
# -------------------------------------------

# The time combine is special. First we generate the list of files we
# need to deal with. 
if args.mode == 'timecombine':
    # Get the directory name where the baseName is:
    path = os.path.dirname(os.path.abspath(args.baseName))

    # Get the full list of files in this directory:
    allFiles = [ f for f in os.listdir(path) if os.path.isfile(os.path.join(path,f)) ]
    files = []

    parts = args.baseName.split("%d")
    maxLength = 0
    for f in allFiles:
        if ((parts[0] == '' or parts[0] in f) and
            (parts[1] == '' or parts[1] in f)):
            # Make sure there is a .cgns in there somwhere
            if '.cgns' in f:
                files.append(f)
                maxLength = max(maxLength,len(f))
                files = sorted(files)

    if args.outFile is None:
        outFile = 'unsteady.plt'
    else:
        outFile = args.outFile

    # Now we make a character array of the file names, and hand if off to
    # fortran for all the actual reading/writing. 
    fileNames = numpy.zeros((len(files), 256), 'c')
    for i in range(len(files)):
        fileNames[i, 0:len(files[i])] = files[i]

    libcgns_utils.time_combine(fileNames, outFile)
    sys.exit(0)


# The 'combine' function is done first sicne it is the only function
# that reads multiple cgns files. 
if args.mode == 'combine':
    grids = []
    for fName in args.gridFiles:
        grid = readGrid(fName)
        grids.append(grid)
        
    combinedGrid = combineGrids(grids)
    combinedGrid.writeToCGNS(args.outFile)

    # This task is now finished
    sys.exit(0)

# Get the current working grid 'curGrid' by reading the input
curGrid = readGrid(args.gridFile)

# The following are "special" and done first since they do not
# have a CGNS output.

if args.mode == 'extract':
    curGrid.extractSurface(args.surfFile)
    sys.exit(0)

if args.mode == 'cgns2plot3d':
    curGrid.writePlot3d(args.plot3dFile)
    sys.exit(0)

# Determine if we have an output file:
try:
    if args.outFile is None:
        # Determine where to put a file:
        dirpath = tempfile.mkdtemp()
        
        # Define a temp output file
        outFileName = os.path.join(dirpath, 'tmp.cgns')
    else:
        outFileName = args.outFile
except:
    outFile = None

# Perform one of the following actions:
if args.mode == 'flip':
    curGrid.flip(args.axis)

elif args.mode == 'scale':
    curGrid.scale(args.scale)

elif args.mode == 'mirror':
    curGrid = mirrorGrid(curGrid, args.axis)

elif args.mode == 'coarsen':
    curGrid.coarsen()

elif args.mode == 'refine':
    curGrid.refine()

elif args.mode == 'split':
    curGrid = splitGrid(curGrid, args.splitFile)

elif args.mode == 'merge':
    curGrid = mergeGrid(curGrid)

elif args.mode == 'connect':
    curGrid.connect()

elif args.mode == 'divide':
    curGrid = divideGrid(curGrid)

elif args.mode == 'autobc':
    curGrid.autoBC(args.radius, args.sym,
                   [args.xOffset, args.yOffset, args.zOffset])

elif args.mode == 'family':
    curGrid.overwriteFamilies(args.familyFile)

elif args.mode == 'familycopy':
    sourceGrid = readGrid(args.sourceFile)
    curGrid.copyFamilyInfo(sourceGrid)

elif args.mode == 'overwritebc':
    curGrid.overwriteBCs(args.bcFile)

elif args.mode == 'rebunch':
    curGrid.rebunch(args.spacing, args.extraCells, args.nodes)

elif args.mode == 'randomize':
    curGrid.randomize(args.seed)

elif args.mode == 'reorder':
    curGrid.reorder(args.intDigits)

elif args.mode == 'symmzero':
    curGrid.symmZero(args.sym)

elif args.mode == 'double2d':
    curGrid.double2D()

elif args.mode == 'cartesian':
    found_overset = False
    for block in curGrid.blocks:
        for boco in block.bocos:
            if boco.type == BC['bcoverset']:
                found_overset = True
    if found_overset:
        curGrid.cartesian(args.cartFile,args.outFile)
    else:
        print ('The CGNS file has no overset boundary conditions')
    sys.exit(0)

elif args.mode == 'simpleCart':
    curGrid.simpleCart(args.dh, args.hExtra, args.nExtra, args.sym, 
                      args.mgcycle, args.outFile)
    sys.exit(0)

elif args.mode == 'simpleOCart':
    curGrid.simpleOCart(args.dh, args.hExtra, args.nExtra, args.sym, 
                      args.mgcycle, args.outFile)
    sys.exit(0)

elif args.mode == 'translate':
    curGrid.translate(args.dx, args.dy, args.dz)

elif args.mode == 'autoOversetBC':
    curGrid.autoOversetBC(args.sym)

elif args.mode == 'autoNearfieldBC':
    curGrid.autoNearfieldBC(args.sym)

elif args.mode == 'autoFarfieldBC':
    curGrid.autoFarfieldBC(args.sym)

elif args.mode == 'include':
    toWrite = []
    for spec in args.rangeSpec.split(','):
        if '-' in spec:
            tmp = spec.split('-')
            start = int(tmp[0])
            end = int(tmp[1])
        else:
            start = int(spec)
            end = int(spec)
        for i in range(start, end+1):
            toWrite.append(i)
    toWrite = numpy.unique(toWrite)
    toWrite.sort()
    curGrid.writeToCGNSSelected(args.outFile, toWrite)
    sys.exit(0)


elif args.mode == 'section':
    if len(curGrid.blocks) != 1:
        print ('section command works only on grids with 1 block')
        sys.exit(0)
    curGrid.blocks[0].section(args.iStart, args.iEnd, args.jStart, args.jEnd,
                              args.kStart, args.kEnd)

elif args.mode == 'explode':
    # Split original multiblock grid in a list of single-block grids
    gridList = explodeGrid(curGrid)

    # Check if the user gave a reference name. Otherwise, use the input name as reference
    if args.outFile is None:
        # Get the base name
        outFile = os.path.splitext(os.path.basename(args.gridFile))[0]
    else:
        outFile = args.outFile

    # Generate a list of names for the files by adding integers to the reference name
    fileNames = [outFile + '_%03d'%index + '.cgns' for index in range(1,len(gridList)+1)]
    
    # Save each grid
    for index in range(len(gridList)):
        gridList[index].writeToCGNS(fileNames[index])

    # Finish execution
    sys.exit(0)

elif args.mode == 'explodeKmin':
    # Split original multiblock grid in a list of single-block grids
    # that contains just the K = 1 face
    gridList = explodeGrid(curGrid,kMin=True)

    # Check if the user gave a reference name. Otherwise, use the input name as reference
    if args.outFile is None:
        # Get the base name
        outFile = os.path.splitext(os.path.basename(args.gridFile))[0]
    else:
        outFile = args.outFile

    # Generate a list of names for the files by adding integers to the reference name
    fileNames = [outFile + '_%03d'%index + '.xyz' for index in range(1,len(gridList)+1)]
    
    # Save each grid
    for index in range(len(gridList)):
        gridList[index].writePlot3d(fileNames[index])

    # Finish execution
    sys.exit(0)

elif args.mode == 'info':
    curGrid.printInfo()
    sys.exit(0)


# Write out the grid.
curGrid.writeToCGNS(outFileName)

# Possibly copy back to the original:
if args.outFile is None:
    shutil.copyfile(outFileName, args.gridFile)
    shutil.rmtree(dirpath)
