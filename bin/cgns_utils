#!/usr/bin/env python
"""
This is the new gateway program to all of the cgns_utils.

Run cgns_utils -help to get a list of all available options. The basic
idea is as follows:

                                              | write new file
read cngs file -> Do some operations on it -> |     .or.
                                              | write modified file
Developed by Dr. Gaetan K. W. Kenway
"""
from __future__ import print_function, division
import sys
import os
import copy
import shutil
import tempfile
import argparse
import numpy
import libcgns_utils
import time

# List out all of the possible options here.
parser = argparse.ArgumentParser(prog='cgns_utils')


subparsers = parser.add_subparsers(
    help='Choose one of the listed operations to perform', dest='mode')

# ------------- Options for 'scale' mode --------------------
p_scale = subparsers.add_parser('scale',
                                help='Scale a grid by a constant factor')
p_scale.add_argument('gridFile', help='Name of input CGNS file')
p_scale.add_argument('scale', help='scale factor', type=float)
p_scale.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'flip' mode --------------------
p_flip = subparsers.add_parser('flip', help='Flip a grid about a plane defined \
by an axis')
p_flip.add_argument('gridFile',
                    help='Name of input CGNS file')
p_flip.add_argument('axis', help="Flip the mesh about plane defined by \
axis: 'x', 'y', 'z'")
p_flip.add_argument('outFile', nargs='?', default=None,
                    help='Optional output file')

# ------------- Options for 'coarsen' mode --------------------
p_coarsen = subparsers.add_parser('coarsen', help='Coarsen a grid uniformly')
p_coarsen.add_argument('gridFile', help='Name of input CGNS file')
p_coarsen.add_argument('outFile', nargs='?', default=None,
                       help='Optional output file')

p_refine = subparsers.add_parser('refine', help='Refine a grid uniformly')
p_refine.add_argument('gridFile', help='Name of input CGNS file')
p_refine.add_argument('outFile', nargs='?', default=None,
                      help='Optional output file')

# ------------- Options for 'extract' mode --------------------
p_extract = subparsers.add_parser('extract',
                                  help='Extract a wall surface from file')
p_extract.add_argument('gridFile', help='Name of input CGNS file')
p_extract.add_argument('surfFile', help='Name of plot3d surface file')

# ------------- Options for 'mirror' mode --------------------
p_mirror = subparsers.add_parser('mirror',
                                 help='Mirror a grid about a plane defined \
                                 by an axis. This doubles the grid size')
p_mirror.add_argument('gridFile', help='Name of input CGNS file')
p_mirror.add_argument('axis',
                      help="Mirror about plane defined by axis: 'x', 'y', 'z'")
p_mirror.add_argument('outFile', nargs='?', default=None,
                      help='Optional output file')

# ------------- Options for 'split' mode --------------------
p_split = subparsers.add_parser('split',
                                help='Face-match a grid. If the grid is \
                                already faced matched, this witll have no \
                                effect')
p_split.add_argument('gridFile', help='Name of input CGNS file')
p_split.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_split.add_argument('--splitFile', nargs='?', default=None,
                     help='Add additional splits specified in split file. Each\
                     line must contain a block index (1 based), idim (1, 2, or 3),\
                     and a 1-based index of the block to split at')

# ------------- Options for 'connect' mode --------------------
p_connect = subparsers.add_parser(
    'connect', help='Determine the block-to-block connectivity information \
    for a point-matched grid')
p_connect.add_argument('gridFile', help='Name of input CGNS file')
p_connect.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'divide' mode --------------------
p_divide = subparsers.add_parser(
    'divide', help='Divide all blocks in the grid into 8 sub-blocks')
p_divide.add_argument('gridFile', help='Name of input CGNS file')
p_divide.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------- Options for 'autobc' mode --------------------
p_bc = subparsers.add_parser(
    'autobc', help='Try to determine boundary conditions for blocks. Only \
    suitable for external flow applications.')
p_bc.add_argument('gridFile', help='Name of input CGNS file')
p_bc.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_bc.add_argument('radius', help='Radius of sphere containing bodies',
                  type=float, default=10.0)
p_bc.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_bc.add_argument('--xOffset', nargs='?', default=0.0, type=float,
                     help='x-coordinate of sphere origin')
p_bc.add_argument('--yOffset', nargs='?', default=0.0, type=float,
                     help='y-coordinate of sphere origin')
p_bc.add_argument('--zOffset', nargs='?', default=0.0, type=float,
                     help='z--coordinate of sphere origin')

# ------------ Options for 'family' mode --------------------
p_fam = subparsers.add_parser(
    'family', help='Overwrite family information')
p_fam.add_argument('gridFile', help='Name of input CGNS file')
p_fam.add_argument('familyFile', help='File containing additional family \
information. Format is (one per line, 1-based blockID): blockID, \
{iLow, iHigh etc}, newFamilyName')
p_fam.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'familycopy' mode --------------------
p_fam = subparsers.add_parser(
    'familycopy', help='Copy family information from two otherwise identical grids')
p_fam.add_argument('gridFile', help='Name of CGNS file to which family information is to be copied')
p_fam.add_argument('sourceFile', help='Name of output CGNS file which contains family information')
p_fam.add_argument('outFile', nargs='?', default=None,
                    help='Optional output file')

# ------------ Options for 'overwritebc' mode --------------------
p_sub = subparsers.add_parser(
    'overwritebc', help='Overwrite boundary condition information', formatter_class=argparse.RawTextHelpFormatter)
p_sub.add_argument('gridFile', help='Name of input CGNS file')
p_sub.add_argument('bcFile', help="File containing additional bc info. The\
File must consist of one or more lines contaning the following data: \n\
<block number> <faceID> <BCType> <family> [key value, ....] \n \
\n\
where: \n\
block number is the block index *IN 1 BASED NUMBERING* \n\
faceID is one of iLow, iHigh jLow, jHigh, kLow or kHigh \n\
BCType is one of the supported CGNS boundary conditions. The supported \n\
BCs are : bcfarfield, bcsymmetryplane bcwall, bcwallinviscid, bcwallviscous \n\
   bcwallviscousheatflux, bcwallviscousisothermal, bcoutflow, bcoutflowsubsonic \n\
   bcinflowsubsonic \n\
family is the family name. \n\
Optionally, additional data may be specified using (key value) pairs. These \n\
can be used to set additional boundary condition data. \n\
\n\
Example lines are as follows: \n\
\n\
7 kLow bcwallviscous wing \n\
4 jHigh bcsymmetryplane sym\n\n")
p_sub.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'rebunch' mode --------------------
p_bunch = subparsers.add_parser(
    'rebunch', help='Rebunch offwall spacing (experimental')
p_bunch.add_argument('gridFile', help='Name of input CGNS file')
p_bunch.add_argument('spacing', help='The desired off-wall spacing', type=float)
p_bunch.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')
p_bunch.add_argument('--extraCells', help='Number of additional cells to \
use in re-bunching. *SHOULD BE A MG NUMBER*.', type=int, default=0)
p_bunch.add_argument('--nodes', help="Only rebunch the first 'nodes' in the \
offwall direction", type=int, default=1)

# ------------ Options for 'cgns2plot3d' mode --------------------
p3d = subparsers.add_parser(
    'cgns2plot3d', help='Convert a cgns file to a plain plot3d file')
p3d.add_argument('gridFile', help='Name of input CGNS file')
p3d.add_argument('plot3dFile', help='Name of output plot3d file')

# ------------ Options for 'randomize' mode --------------------
p_ran = subparsers.add_parser(
    'randomize', help='Randomize the block orientation and order. Useful for testing.')
p_ran.add_argument('gridFile', help='Name of input CGNS file')
p_ran.add_argument('seed', type=int, default=0, help='Seed for random generator. \
Specifying a seed will make process deterministic.')
p_ran.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'symmzero' mode --------------------
p_sym = subparsers.add_parser(
    'symmzero', help='Hard-zero any nodes within a given tolerance. Used for ensuring planar symmetry planes.')
p_sym.add_argument('gridFile', help='Name of input CGNS file')
p_sym.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_sym.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'timecombine' mode  --------------------
p_tc = subparsers.add_parser(
    'timecombine', help='Combine cgns files from time accurate simulation into unsteady tecplot file.')
p_tc.add_argument('baseName', help="baseName of the files. Use %%d to denote the counter.")
p_tc.add_argument('outFile', nargs='?', default=None,
                     help='Output file name. If not given, unsteady.plt is used')

# ------------ Options for 'double2d' mode  --------------------
p_dd = subparsers.add_parser(
    'double2d', help='Take a 2d mesh one cell wide and make it two cells wide.')
p_dd.add_argument('gridFile', help='Name of input CGNS file')
p_dd.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'combine' mode  --------------------
p_dd = subparsers.add_parser(
    'combine', help='Take 2 or more cgns files and combine them into a single file.')
p_dd.add_argument('gridFiles', metavar='files', type=str, nargs='+', help='Name of CGNS files to combine')
p_dd.add_argument('outFile', type=str, help='Output CGNS file name')

# ------------ Options for 'cartesian' mode --------------------
p_sub = subparsers.add_parser(
    'cartesian', help='Generates a background cartesian mesh', formatter_class=argparse.RawTextHelpFormatter)
p_sub.add_argument('gridFile', help='Name of input CGNS file')
p_sub.add_argument('cartFile', help="File containing background mesh info. The file must consist of \n\
4 lines contaning the following data: \n\
  <extensionXneg> <extensionYneg> <extensionZneg> \n\
  <extensionXpos> <extensionYpos> <extensionZpos> \n\
  <numNodesX> <numNodesY> <numNodesZ> \n\
  <weightGRX> <weightGRY> <weightGRZ> \n\
\n\
where: \n\
extension is the distance of the cartesian box\n\
  face to the corresponding bounding box face divided by the\n\
  bounding box length. We need 2 values of extension per \n\
  direction as we have two parallel faces for each one of them.\n\
numNodes is the number of nodes that should be used along the \n\
  edges of the cartesian mesh. If you want one symmetry plane\n\
  in the z direction, for instance, you need to set one of the\n\
  extensionZ values to 0. If you want two symmetry planes in\n\
  the z direction, (e.g. to run a 2D case) you need to set both\n\
  extensionZ values to 0.\n\
weightGR are values between 0.0 and 1.0 used to balance edge\n\
  growth ratio and cell volume resolution mismatch during the\n\
  optimization. If weightGR = 0, the optimizer will not care\n\
  about the growth ratios at the farfield and will just try\n\
  to match the bounding box resolution. If weightGR = 1, the\n\
  optimizer will not care about the bounding box resolution\n\
  and will just try to get an uniform growth ratio. This\n\
  results in an uniform mesh.\n\n\
example:\n\
  10 10 0\n\
  10 10 10\n\
  65 65 65\n\
  0.1 0.1 0.1\n")
p_sub.add_argument('outFile', help='Name of output CGNS file \n\
The output file contains only one cartesian block. The input \n\
mesh is not included and BCs are applied.\n')

# ------------ Options for 'translate' mode  --------------------
p_t = subparsers.add_parser(
    'translate', help='Translate a grid.')
p_t.add_argument('gridFile', help='Name of input CGNS file')
p_t.add_argument('dx', help='x-displacement', type=float)
p_t.add_argument('dy', help='y-displacement', type=float)
p_t.add_argument('dz', help='z-displacement', type=float)
p_t.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# ------------ Options for 'autoOversetBC' mode
p_obc = subparsers.add_parser(
    'autoOversetBC', help='Automatically generate connectivity and boundary conditions'
    'for an overset near field mesh generated by pyHyp. It assumes the surface is a '
    'BCWallViscous and the outer boundary is a BCOverset condtiion.'
    'Only used with pyHyp hyperbolically generated meshes.')
p_obc.add_argument('gridFile', help='Name of input CGNS file')
p_obc.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_obc.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')


# ------------ Options for 'autoNearfieldBC' mode
p_anf = subparsers.add_parser(
    'autoNearfieldBC', help='Automatically generate connectivity and boundary conditions'
    'for an overset near field mesh with possible symmetry plane.')
p_anf.add_argument('gridFile', help='Name of input CGNS file')
p_anf.add_argument('sym', help='Normal for possible symmetry plane.',
                  choices=['x', 'y', 'z'])
p_anf.add_argument('outFile', nargs='?', default=None,
                     help='Optional output file')

# Finally get the arguments we need!
args = parser.parse_args()

# These are taken from the CNGS include file (cgnslib_f.h in your cgns library folder)
BC = {'bcfarfield':7,
      'bcsymmetryplane':16,
      'bcwall':20,
      'bcwallinviscid':21,
      'bcwallviscous':22,
      'bcwallviscousheatflux':23,
      'bcwallviscousisothermal':24,
      'bcoutflow':13,
      'bcoutflowsubsonic':14,
      'bcoutflowsupersonic':15,
      'bcinflowsubsonic':10,
      'bcoverset':1} #The Overset BC will be considered as a CG_USERDEFINED option ()

CG_MODE_READ = 0
CG_MODE_WRITE = 1

class Grid(object):
    """Represent a complete 3D multiblock grid"""
    def __init__(self):
        self.blocks = []
        self.topo = None
        
    def addBlock(self, blk):
        """Add a block to the grid"""
        self.blocks.append(blk)

    def writeToCGNS(self, fileName):
        """Write what is in this grid tree to the fileName provided"""
        outFile = libcgns_utils.openfile(fileName, CG_MODE_WRITE)
        for blk in self.blocks:
            blk.writeToCGNS(outFile)
        libcgns_utils.closefile(outFile)

    def writePlot3d(self, fileName):
        """Write what is in this grid tree to the plot3d filename
        provided. This is mostly done in python so will be slow-ish."""
        f = open(fileName, 'w')
        f.write('%d\n'% len(self.blocks))
        for blk in self.blocks:
            blk.writeDimsPlot3d(f)
        for blk in self.blocks:
            blk.writeCoordsPlot3d(f)
        f.close()
        
    def scale(self, scaleFact):
        """Scale blocks in this grid"""
        for blk in self.blocks:
            blk.scale(scaleFact)
            
    def flip(self, axis):
        """Flip the grid about a axis, 'x', 'y' or 'z'"""
        for blk in self.blocks:
            blk.flip(axis)

    def coarsen(self):
        """Coarsen the block by taking every-other grid line"""
        for blk in self.blocks:
            blk.coarsen()
            
    def refine(self):
        """Refine he block by interpolating every-other grid line"""
        for blk in self.blocks:
            blk.refine()
                
    def renameBlocks(self):
        """Rename all blocks in a consistent fashion"""
        i = 1
        for blk in self.blocks:
            blk.name = 'domain.%5.5d'% i
            i += 1
    def renameBCs(self):
        """Rename all block boundary conditions in a consistent fashion"""
        i = 1
        for blk in self.blocks:
            for boco in blk.bocos:
                boco.name = 'BC%d'% i
                i += 1
                
    def extractSurface(self, fileName):
        """ Extract wall surfaces and write to plot3d file"""
        patches = []
        for blk in self.blocks:
            patches.extend(blk.extractWallSurfaces())
        if len(patches) > 0:
            f = open(fileName, 'w')
            f.write('%d\n' % len(patches))
            for i in range(len(patches)):

                f.write('%d %d 1\n' %(patches[i].shape[0], 
                                      patches[i].shape[1]))
            for i in range(len(patches)):
                patches[i][:, :, 0].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
                patches[i][:, :, 1].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
                patches[i][:, :, 2].flatten(1).tofile(f, sep='\n', format='%20.15g')
                f.write('\n')
            f.close()
        else:
            print ('Warning: No wall surfaces found!')

    def overwriteFamilies(self, familyFile):
        """Overwrite families of BC with information given in the
        family file"""
        fams = []
        f = open(familyFile,'r')
        for line in f:
            aux = line.split()
            if len(aux) == 3:
                fams.append([int(aux[0]), aux[1].lower(), aux[2]])
        f.close()

        for fam in fams:
            self.blocks[fam[0]-1].overwriteFamily(fam[1], fam[2])

    def copyFamilyInfo(self, otherGrid):
        """Copy family information out of another grid"""
        for i in range(len(self.blocks)):
            for j in range(len(self.blocks[i].bocos)):
                self.blocks[i].bocos[j].family = otherGrid.blocks[i].bocos[j].family

    def overwriteBCs(self, bcFile):
        """Overwrite BCs with information given in the file"""

        f = open(bcFile, 'r')
        for line in f:
            aux = line.split()
            block = int(aux[0])-1
            face = aux[1]
            bctype = aux[2]
            family = aux[3]
            data = {}
            for i in range(4, len(aux), 2):
                data[aux[i]] = float(aux[i+1])
                
            self.blocks[block].overwriteBCs(face, bctype, family, data)
        f.close()

    def autoOversetBC(self, sym):
        """This is essentially a simplified version of autoBC that flags all
        kMin faces as walls and all kMax faces as BCOverset"""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Next check for a wall-type boundary condition if
                    # we have a kMin face
                    if pointRanges[2, 0, i] == pointRanges[2, 1, i] == 1:
                        bocoType = BC['bcwallviscous']
                        famName = 'wall'
                    elif (pointRanges[2, 0, i] == pointRanges[2, 1, i] == 
                          self.blocks[blockID].dims[2]):
                        # Must be a overset outer bound
                        bocoType = BC['bcoverset']
                        famName = 'overset'
                
                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))
 
        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def autoNearfieldBC(self, sym):
        """This is essentially a simplified version of autoBC that flags all
        boundaries as BCOverset except for possible symmetry planes."""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Flag as overset
                    bocoType = BC['bcoverset']
                    famName = 'overset'
                
                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))
 
        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def double2D(self):
        """Doubles a mesh in the "2d" direction. Ie the direction with one
        cell"""
        for blk in self.blocks:
            blk.double2D()

    def cartesian(self, cartFile, outFile):
        """Generates a cartesian mesh around the provided grid"""

        # PARAMETERS
        inLayer = 2 # How many layers of the overset interpolation faces will be used for volume computation

        print ('Running cartesian grid generator')

        # Preallocate arrays
        extensions = numpy.zeros((2,3),order='F')
        nNodes = numpy.zeros(3,order='F')
        weightGR = numpy.zeros(3,order='F')
        numBins = numpy.zeros(3,order='F')

        # Read four lines of the cartesian specs file
        with open(cartFile, 'r') as f:
            lines = list(f)
        extensions[0,:] = lines[0].split()
        extensions[1,:] = lines[1].split()
        nNodes[:] = lines[2].split()
        weightGR[:] = lines[3].split()

        # Specify number of bins
        numBins[:] = 1 #The tangent law only works for single bin

        # Initialize bounding box coordinates using the first point of the first zone
        xBounds = numpy.zeros((2,3),order='F')
        xBounds[0,0] = self.blocks[0].coords[0,0,0,0] # Using the first point for initialization
        xBounds[1,0] = self.blocks[0].coords[0,0,0,0] # because I can't use 0
        xBounds[0,1] = self.blocks[0].coords[0,0,0,1]
        xBounds[1,1] = self.blocks[0].coords[0,0,0,1]
        xBounds[0,2] = self.blocks[0].coords[0,0,0,2]
        xBounds[1,2] = self.blocks[0].coords[0,0,0,2]
        binVolX = numpy.zeros(numBins[0], order='F') # Assign zeroes to all bins
        binVolY = numpy.zeros(numBins[1], order='F')
        binVolZ = numpy.zeros(numBins[2], order='F')
        binCellsX = numpy.zeros(numBins[0], order='F', dtype=int) # Initialize cells counter for each bin
        binCellsY = numpy.zeros(numBins[1], order='F', dtype=int)
        binCellsZ = numpy.zeros(numBins[2], order='F', dtype=int)

        # Loop over all blocks to find the bounding box coordinates
        for index in range(len(self.blocks)):
            # Loop over all BCs of this block
            for boco in self.blocks[index].bocos:
                # Check if we have an overset boundary condition
                if boco.type == BC['bcoverset']:
                    # Find overset BC face and select some inner layers to compute volume
                    r = boco.ptRange
                    if r[0][0] == r[0][1] == 1: #ilow detected
                        imin = 0
                        imax = min(0+inLayer,self.blocks[index].dims[0])
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[0][0] == r[0][1] == self.blocks[index].dims[0]: #ihigh detected
                        imin = max(self.blocks[index].dims[0]-inLayer, 0)
                        imax = self.blocks[index].dims[0]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == 1: #jlow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = 0
                        jmax = min(0+inLayer,self.blocks[index].dims[1])
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == self.blocks[index].dims[1]: #jhigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = max(self.blocks[index].dims[1]-inLayer, 0)
                        jmax = self.blocks[index].dims[1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[2][0] == r[2][1] == 1: #klow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = 0
                        kmax = min(0+inLayer,self.blocks[index].dims[2])
                    elif r[2][0] == r[2][1] == self.blocks[index].dims[2]: #khigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = max(self.blocks[index].dims[2]-inLayer, 0)
                        kmax = self.blocks[index].dims[2]
                    # Use the range to compute average volume
                    libcgns_utils.findbounds(self.blocks[index].coords[imin:imax, jmin:jmax, kmin:kmax, :], xBounds)

        # Loop over all blocks to find the bin volumes
        for index in range(len(self.blocks)):
            # Loop over all BCs of this block
            for boco in self.blocks[index].bocos:
                # Check if we have an overset boundary condition
                if boco.type == BC['bcoverset']:
                    # Find overset BC face and select some inner layers to compute volume
                    r = boco.ptRange
                    if r[0][0] == r[0][1] == 1: #ilow detected
                        imin = 0
                        imax = min(0+inLayer,self.blocks[index].dims[0])
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[0][0] == r[0][1] == self.blocks[index].dims[0]: #ihigh detected
                        imin = max(self.blocks[index].dims[0]-inLayer, 0)
                        imax = self.blocks[index].dims[0]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == 1: #jlow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = 0
                        jmax = min(0+inLayer,self.blocks[index].dims[1])
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[1][0] == r[1][1] == self.blocks[index].dims[1]: #jhigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = max(self.blocks[index].dims[1]-inLayer, 0)
                        jmax = self.blocks[index].dims[1]
                        kmin = r[2][0]-1
                        kmax = r[2][1]
                    elif r[2][0] == r[2][1] == 1: #klow detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = 0
                        kmax = min(0+inLayer,self.blocks[index].dims[2])
                    elif r[2][0] == r[2][1] == self.blocks[index].dims[2]: #khigh detected
                        imin = r[0][0]-1
                        imax = r[0][1]
                        jmin = r[1][0]-1
                        jmax = r[1][1]
                        kmin = max(self.blocks[index].dims[2]-inLayer, 0)
                        kmax = self.blocks[index].dims[2]
                    # Use the range to compute average volume
                    libcgns_utils.computevolumes(self.blocks[index].coords[imin:imax, jmin:jmax, kmin:kmax, :], xBounds, \
                                                 binVolX, binVolY, binVolZ, binCellsX, binCellsY, binCellsZ)

        # DEFINE UNIDIMENSIONAL GRID GENERATION ROUTINES

        # Define tangent bunching law
        def tanDist(Sp1,Sp2,N):

            # This is the tangential spacing developed by Ney Secco
            # This bunching law is coarse at the ends an fine at the middle
            # of the interval, just like shown below:
            # |    |   |  | || |  |   |    |

            # Sp1: initial spacing (within the [0,1] interval)
            # Sp2: final spacing (within the [0,1] interval)
            # N: number of nodes
    
            # IMPORTS
            from numpy import tan, arange, pi
            from scipy.optimize import minimize
    
            # Convert number of nodes to number of cells, because I derived the equations using
            # N the as number of cells =P.
            N = N-1

            # Define objective function
            def func(P):
                # Split variables
                a = P[0]
                e = P[1]
                c = P[2]
                # Find b
                b = e - c
                # Equations
                Eq1 = a*(tan(b+c) - tan(c)) - 1
                Eq2 = a*(tan(b/N+c) - tan(c)) - Sp1
                Eq3 = a*(tan(b+c) - tan(b*(1-1/N)+c)) - Sp2
                # Cost function
                J = Eq1**2 + Eq2**2 + Eq3**2
                # Return
                return J

            # Define bounds for the problem
            a_bounds = [(0, None)]
            e_bounds = [(0, pi/2)]
            c_bounds = [(-pi/2 , 0)]
            bounds = a_bounds + e_bounds + c_bounds

            # Define initial guess
            a_start = 1.0
            e_start = pi/4
            c_start = -pi/4
            x_start = [a_start, e_start, c_start]

            # Optimize
            res = minimize(func, x_start, method='SLSQP', bounds=bounds, \
                           options={'maxiter':1000,'disp':False,'ftol':1e-12})

            # Split variables
            a = res.x[0]
            e = res.x[1]
            c = res.x[2]

            # Find other parameters
            b = e - c
            d = -a*tan(c)

            # Generate spacing
            index = arange(N+1)
            S = a*tan(b*index/N+c)+d
            
            # Force the extremes to 0 and 1 so that we always meet the bounds
            # (this is to avoid numerical issues with symmetry planes)
            S[0] = 0.0
            S[-1] = 1.0

            # Return spacing
            return S

        # Define function that optimizes bunching law to match grid resolution

        def generateGrid(xmin, xmax, extension1, extension2, nNodes, binVol, weightGR):

            # xmin: float -> position where the bounding box begins
            # xmax: float -> position where the bounding box ends
            # extension1: float > 0 -> ratio between the negative farfield distance and the bounding box length:
            #                          extension1 = (xmin-negative_farfield_position)/(xmax-xmin)
            # extension2: float > 0 -> ratio between the positive farfield distance and the bounding box length:
            #                          extension2 = (positive_farfield_position-xmax)/(xmax-xmin)
            # nNodes: integer > 0 -> Number of nodes along the edge
            # binVol: float > 0 -> Average volume of the bounding box cells (foreground mesh)
            # weightGR: 0 < float < 1 -> Weight used to balance growth ratio and cell volume during the optimization.
            #                            If weightGR = 0, the optimizer will not care about the growth ratios at the
            #                            farfield and will just try to match the bounding box resolution.
            #                            If weightGR = 1, the optimizer will not care about the bounding box resolution
            #                            and will just try to get an uniform growth ratio. This results in an uniform mesh.

            # IMPORTS
            from numpy import array, mean, zeros
            from scipy.optimize import minimize

            # Compute farfield coordinates
            x0 = xmin - (xmax-xmin)*extension1
            xf = xmax + (xmax-xmin)*extension2

            # Get number of bins and bin size
            nBins = len(binVol)
            dxBin = (xmax-xmin)/nBins

            # Get bin edges
            binEdge = binVol**(1./3.)

            # Define objective function
            def func(P):
                # Split variables
                Sp1 = P[0]
                Sp2 = P[1]

                # Generate grid coordinates with tangent bunching law
                S = tanDist(Sp1,Sp2,nNodes)

                # Rescale the interval
                S = x0 + S*(xf-x0)

                # Compute edge size of each cell
                E = S[1:]-S[:-1]

                # Initialize edge error
                edgeError = 0

                # Find cells that are inside each bin and check the edge difference
                for binIndex in range(nBins):
                    # Find bin interval
                    x0bin = xmin + dxBin*binIndex
                    xfbin = xmin + dxBin*(binIndex+1)
                    # Find cells that touch this interval and get their edges
                    bol = -(((S[:-1] < x0bin)*(S[1:] < x0bin))+((S[:-1] > xfbin)*(S[1:] > xfbin)))
                    bolEdges = E[bol]
                    #print bol
                    # Compute edge mismatch and increment variable
                    edgeError = edgeError + mean((bolEdges-binEdge[binIndex])**2)/2

                # Compute term regarding growing ratios at the ends
                if nNodes > 3:
                    growthRatio = ((S[1]-S[0])/(S[2]-S[1])-1.0)**2 + ((S[-1]-S[-2])/(S[-2]-S[-3])-1)**2
                else: #There's no way to define growth ratio when we have less than 3 cells
                    growthRatio = 0

                # Return objective function
                return (1-weightGR)*edgeError/mean(binEdge) + weightGR*growthRatio
                # Note that the edgeError is normalized so that the weighed average makes sense

            # Define initial guess based on uniform spacing
            Sp1_start = 1/(nNodes-1)
            Sp2_start = 1/(nNodes-1)
            x_start = array([Sp1_start, Sp2_start])

            # Optimize
            res = minimize(func, x_start, method='Nelder-Mead',
                           options={'maxiter':2000,'disp':True,'xtol':1e-8,'ftol':1e-8})

            # Split variables
            Sp1 = res.x[0]
            Sp2 = res.x[1]

            # Generate grid
            S = tanDist(Sp1,Sp2,nNodes)
            S = x0 + S*(xf-x0)

            # Return grid
            return S

        # Generate grid for each dimension
        Sx = generateGrid(xBounds[0,0], xBounds[1,0], extensions[0,0], extensions[1,0], nNodes[0], binVolX[0:1], weightGR[0])
        Sy = generateGrid(xBounds[0,1], xBounds[1,1], extensions[0,1], extensions[1,1], nNodes[1], binVolY[0:1], weightGR[1])
        Sz = generateGrid(xBounds[0,2], xBounds[1,2], extensions[0,2], extensions[1,2], nNodes[2], binVolZ[0:1], weightGR[2])

        # Compute growth ratios
        if nNodes[0] > 3:
            gx = max((Sx[1]-Sx[0])/(Sx[2]-Sx[1]), (Sx[-1]-Sx[-2])/(Sx[-2]-Sx[-3]))
        else:
            gx = None
        if nNodes[1] > 3:
            gy = max((Sy[1]-Sy[0])/(Sy[2]-Sy[1]), (Sy[-1]-Sy[-2])/(Sy[-2]-Sy[-3]))
        else:
            gy = None
        if nNodes[2] > 3:
            gz = max((Sz[1]-Sz[0])/(Sz[2]-Sz[1]), (Sz[-1]-Sz[-2])/(Sz[-2]-Sz[-3]))
        else:
            gz = None

        # Print growth ratios
        print ('')
        print ('Maximum growth ratios along each direction:')
        print ('X: ',gx)
        print ('Y: ',gy)
        print ('Z: ',gz)
        if max(gx,gy,gz) > 1.2:
            print ("You may bring weightGR closer to 1 to decrease ratios")
        print ('')

        # Allocate coordinates block
        X = numpy.zeros((nNodes[0],nNodes[1],nNodes[2],3))

        # Write grid coordinates
        Xx, Xy, Xz = numpy.meshgrid(Sx, Sy, Sz)
        X[:,:,:,0] = Xx
        X[:,:,:,1] = Xy
        X[:,:,:,2] = Xz

        # Open a new CGNS file
        cg = libcgns_utils.openfile(outFile, CG_MODE_WRITE)

        # Write a Zone to it
        zoneID = libcgns_utils.writezone(cg, 'cartesian', nNodes)

        # Write mesh coordinates
        libcgns_utils.writecoordinates(cg, zoneID, X)

        # CLose file
        libcgns_utils.closefile(cg)

        # Print
        print ('Mesh successfully generated and stored in: '+outFile)

    def split(self, extraSplits):

        """Recursively propagate splits due to boundary conditions or
        B2B information"""

        # First generate a mapping between block name and its index:
        mapping = {}
        for iBlock in range(len(self.blocks)):
            mapping[self.blocks[iBlock].name] = iBlock

        for iBlock in range(len(self.blocks)):
            splits = []
            for boco in self.blocks[iBlock].bocos:
                splits.extend(getSplits(boco.ptRange))
            for b2b in self.blocks[iBlock].B2Bs:
                splits.extend(getSplits(b2b.ptRange))

            # Now just add the (unique) splits for this block: DON't
            # USE numpy.unique it doesn't actually work for tuples.
            newSplits = []
            for split in splits:
                if not split in newSplits:
                    newSplits.append(split)
            splits = newSplits

            for split in splits:
                self._addSplit(iBlock, split[0]+1, split[1], mapping)
                
        # And Add the extra splits:
        for split in extraSplits:
            self._addSplit(split[0]-1, split[1], split[2], mapping)

    def _addSplit(self, iBlock, iDim, index, mapping):
        """Recursive routine to add a split to block 'iBlock', on
        dimension 'iDim' at index 'index'. NOTE IDIM is 1 based!"""
        if index in self.blocks[iBlock].splits[iDim-1]:
            return # This is the main recursive return
        else:
            # Add the split and call any others we need
            self.blocks[iBlock].splits[iDim-1].append(index)
            self.blocks[iBlock].splits[iDim-1].sort()

            for b2b in self.blocks[iBlock].B2Bs:
                low = min(b2b.ptRange[iDim-1, :])
                high = max(b2b.ptRange[iDim-1, :])

                # Index must be fully contained:
                if index > low and index < high:
                    newBlock = mapping[b2b.donorName]
                    iDim_new = b2b.transform[iDim-1]
                    offset = index - low
                    abs_idim = abs(iDim_new)
                    donor_high = max(b2b.donorRange[abs_idim-1, :])
                    donor_low = min(b2b.donorRange[abs_idim-1, :])

                    if iDim_new >= 0:
                        index_new = donor_low + offset
                    else:
                        index_new = donor_high - offset

                    # Finally recursively call itself for the new
                    # block, dimension and index
                    self._addSplit(newBlock, abs_idim, index_new, mapping)
                            
    def connect(self):
        """Generate block-to-block connectivity information for a grid. It
        does not need to be face matched, only point matched"""
        isize = 0
        for i in range(len(self.blocks)):
            blk = self.blocks[i]
            isize += blk.dims[0]*blk.dims[1]*blk.dims[2]

        # Allocate space for all coordinates
        coords = numpy.zeros(isize*3)
        sizes = []
        istart = 0
        for i in range(len(self.blocks)):
            blk = self.blocks[i]
            iend = istart + blk.dims[0]*blk.dims[1]*blk.dims[2]
            coords[istart*3:3*iend] = blk.coords.flatten()
            sizes.append(blk.dims)
            istart = iend
        
        # Get our list of sizes
        sizes  = numpy.vstack(sizes)

        # Run the fortran code to generate all the connectivities
        libcgns_utils.computeconnectivity(coords, sizes.T)
        nPatches = libcgns_utils.getnpatches()
        types, pointRanges, myIDs, pointRangeDonors, \
            transforms, donorIDs, faceAvgs, faceNormals = \
            libcgns_utils.getpatchinfo(nPatches)
        libcgns_utils.deallocpatches()

        # Remove all existing B2B info
        for blk in self.blocks:
            blk.B2Bs = []

        for i in range(nPatches):
            blockID = myIDs[i] - 1
            
            if types[i] == 1: # B2B
                connectName = 'SF%d'%i
                donorName = self.blocks[donorIDs[i]-1].name
                
                self.blocks[blockID].B2Bs.append(B2B(
                    connectName, donorName, pointRanges[:, :, i], 
                    pointRangeDonors[:, :, i], transforms[:, i]))

        # Return most of the information we computed since other
        # routines (autobc for example) may need this.

        return types, pointRanges, myIDs, faceAvgs, faceNormals

    def autoBC(self, radius, sym, offset):
        """This function will try to generate boundary condition
        information for all patches that are not part of a
        block-to-block connection. If a surface is inside the sphere,
        it gets counted as a wall, if it is outside it is a farfield
        condition. If the surface is flat and a coordinate is zero, it
        gets treated as a symmetry plane."""

        # Remove any BCinfo/B2B info we may have.
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []

        if sym == 'x':
            symAxis = 0
        elif sym == 'y':
            symAxis = 1
        else:
            symAxis = 2

        symNormal = [0.0, 0.0, 0.0]
        symNormal[symAxis] = 1.0

        # Do the b2b by running connect:
        types, pointRanges, myIDs, faceAvg, faceNormal = self.connect()
        
        # Loop over all subfaces and deal with the BCs
        for i in range(len(types)):
            blockID = myIDs[i] - 1
            
            if types[i] == 0: # Boco
                coor_check = abs(faceAvg[symAxis, i]) < 1e-3
                dp_check = abs(numpy.dot(faceNormal[:, i], symNormal)) > 0.98
                if dp_check and coor_check:
                    bocoType = BC['bcsymmetryplane']
                    famName = 'sym'
                else:
                    # Next check for a wall-type boundary condition if
                    # the face avg is inside the sphere:

                    if numpy.linalg.norm(faceAvg[:, i] - offset) < radius:
                        bocoType = BC['bcwallviscous']
                        famName = 'wall'
                    else:
                        # Must be a farfield
                        bocoType = BC['bcfarfield']
                        famName = 'far'
                
                # Now simply add the boco
                self.blocks[blockID].addBoco(Boco(
                    'dummy', bocoType, pointRanges[:, :, i], famName))
 
        # Lastly rename the BCs to be consistent
        self.renameBCs()

    def rebunch(self, spacing, extraCells, nStar):
        """Perform rebunching on offwall-directions. The user should
        be *VERY* careful with this function. It will *only* work for
        grids that that have 'O-type' topologies around the
        surface. This is typical of viscous grids. The main
        application is to rebunch nodes in the boundary layer to adapt
        an existing grid for a different reynolds number"""

        for blk in self.blocks:
            blk.rebunch(spacing, extraCells, nStar)
            blk.B2Bs = []
            blk.BCs = []
        self.connect()

    def randomize(self, seed):
        """Perform random reording of grid orientation and block numbers. This
        method destroys *ALL* boundary condition information. Grid
        connectivity is recomputed on the reorginized grid. Actual
        nodal locations remain precisely unchanged; only the grid
        ordering changes. Block handendness is not necessairly
        preserved.
        """
        numpy.random.seed(seed)
        for blk in self.blocks:
            blk.bocos = []
            blk.B2Bs = []
            blk.randomize()

        # Finally reconnect
        self.connect()
        
    def symmZero(self, sym):
        """Zero nodes along axis 'sym'"""
        if sym == 'x':
            idir = 0
        elif sym == 'y':
            idir = 1
        elif sym == 'z':
            idir = 2
        for blk in self.blocks:
            blk.symmZero(idir)

    def translate(self, dx, dy, dz):
        for blk in self.blocks:
            blk.coords[:, :, :] += [dx, dy, dz]

class Block(object):
    """Class for storing information related to a single block
    structured zone"""
    
    def __init__(self, zoneName, dims, coords):
        self.name = zoneName.strip()
        self.dims = dims
        self.coords = coords
        self.bocos = []
        self.B2Bs = []
        self.splits = [[1, dims[0]], 
                       [1, dims[1]], 
                       [1, dims[2]]]
        self.bocoCounter = 0

    def addBoco(self, boco):
        """ A add a boundary condition to this block"""
        self.bocos.append(boco)
        
    def addB2B(self, b2b):
        """ A  block-2-block connection to this block"""
        self.B2Bs.append(b2b)

    def writeToCGNS(self, cg):
        """ Write all information in this block to the cg file handle"""
        zoneID = libcgns_utils.writezone(cg, self.name, self.dims)
        libcgns_utils.writecoordinates(cg, zoneID, self.coords)

        for boco in self.bocos:
            iBC = libcgns_utils.writebc(cg, zoneID, boco.name, boco.family, 
                                        boco.ptRange, boco.type)
            writeHeader = True
            for key in boco.data:
                libcgns_utils.writebcdata(cg, zoneID, boco.type, iBC, 
                                          key, boco.data[key], writeHeader)
                writeHeader = False

        for b2b in self.B2Bs:
            libcgns_utils.writeb2b(cg, zoneID, b2b.name, b2b.donorName,
                                   b2b.ptRange, b2b.donorRange,
                                   b2b.transform)

    def writeDimsPlot3d(self, f):
        """Write dimensions to a plot3d file"""
        f.write('%d %d %d\n'% (self.dims[0], self.dims[1], self.dims[2]))

    def writeCoordsPlot3d(self, f):
        """Write coordinates to plot3d file"""
        for iDim in range(3):
            self.coords[:, :, :, iDim].flatten(1).tofile(f, sep="\n", format='%20.15g')
            f.write('\n')
            
    def scale(self, scaleFact):
        """Scale the coordinates"""
        self.coords *= scaleFact

    def flip(self, axis):
        """Flip coordinates by plane defined by 'axis'"""
        if axis.lower() == 'x':
            index = 0
        elif axis.lower() == 'y':
            index = 1
        elif axis.lower() == 'z':
            index = 2
        self.coords[:, :, :, index] = -self.coords[:, :, :, index]

        # HOWEVER just doing this results in a left-handed block (if
        # the original block was right handed). So we have to also
        # reverse ONE of the indices 
        for k in range(self.dims[2]):
            for j in range(self.dims[1]):
                for idim in range(3):
                    self.coords[:, j, k, idim] = self.coords[::-1, j, k, idim]
        # AND we now have to flip the BC's on i-faces since they will
        # now be on the other side:
        for boco in self.bocos:
            if (boco.ptRange[0, 0] == boco.ptRange[0, 1] and 
                boco.ptRange[0, 0] == 1):
                boco.ptRange[0,0] = self.dims[0]
                boco.ptRange[0,1] = self.dims[0]
            elif (boco.ptRange[0, 0] == boco.ptRange[0, 1] and 
                  boco.ptRange[0, 0] == self.dims[0]):
                boco.ptRange[0,0] = 1
                boco.ptRange[0,1] = 1

    def coarsen(self):
        """Coarsen the block uniformly. We will update the boundary
        conditions and B2B if necessary"""
        self.coords = self.coords[0::2, 0::2, 0::2, :]
        self.dims[0] = self.coords.shape[0]
        self.dims[1] = self.coords.shape[1]
        self.dims[2] = self.coords.shape[2]
        for boco in self.bocos:
            boco.coarsen()
        for b2b in self.B2Bs:
            b2b.coarsen()

    def refine(self):
        """Refine the block uniformly. We will also update the
        boundary conditions and B2Bs if necessary"""
        self.coords = libcgns_utils.refine(self.coords)
        self.dims[0] = self.coords.shape[0]
        self.dims[1] = self.coords.shape[1]
        self.dims[2] = self.coords.shape[2]
        for boco in self.bocos:
            boco.refine()
        for b2b in self.B2Bs:
            b2b.refine()

      
    def double2D(self):
        """Double in just the 2D direction"""
        # First find the 2D direction
        if self.dims[2] == 2:
            newCoords = numpy.zeros((self.dims[0], self.dims[1], self.dims[2]+1, 3))
            for i in range(self.dims[0]):
                for j in range(self.dims[1]):
                    newCoords[i, j, 0, :] = self.coords[i, j, 0, :]
                    newCoords[i, j, 2, :] = self.coords[i, j, 1, :]
                    newCoords[i, j, 1, :] = 0.5*(newCoords[i, j, 0, :] + 
                                                 newCoords[i, j, 2, :])
            for boco in self.bocos:
                for j in range(2):
                    if boco.ptRange[2, j] == 2:
                        boco.ptRange[2, j] = 3
            for b2b in self.B2Bs:
                for j in range(2):
                    if b2b.ptRange[2, j] == 2:
                        b2b.ptRange[2, j] = 3
                    if b2b.donorRange[2, j] == 2:
                        b2b.donorRange[2, j] = 3

            self.coords = newCoords
            self.dims = [self.dims[0], self.dims[1], 3]

    def getSplitBlocks(self):
        """Return a list of blocks that have been split according to
        the self.splits array. This is used for the 'split' operation
        as well as for the 'divide' operation. Boundary information is
        kept but connectivity information is removed"""
        blkList = []
        s = self.splits # For cleaner code below

        for i in range(len(s[0])-1):
            for j in range(len(s[1])-1):
                for k in range(len(s[2])-1):
                    newCoords = self.coords[
                        s[0][i]-1:s[0][i+1],
                        s[1][j]-1:s[1][j+1],
                        s[2][k]-1:s[2][k+1], :].copy()

                    dims = [newCoords.shape[0], newCoords.shape[1],
                            newCoords.shape[2]]
                    blk = Block('dummy', dims, newCoords)

                    # Loop over the 6 faces and determine what BC they
                    # came from:

                    for boco in self.bocos:
                        # iLow
                        chkRange = [[s[0][i], s[0][i]],
                                    [s[1][j], s[1][j+1]],
                                    [s[2][k], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, 1], [1, dims[1]], [1, dims[2]]],
                                 boco.family))

                        # iHigh
                        chkRange = [[s[0][i+1], s[0][i+1]],
                                    [s[1][j],   s[1][j+1]],
                                    [s[2][k],   s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[dims[0], dims[0]], [1, dims[1]], [1, dims[2]]],
                                boco.family))

                        # jLow
                        chkRange = [[s[0][i], s[0][i+1]],
                                    [s[1][j], s[1][j]],
                                    [s[2][k], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, 1], [1, dims[2]]],
                                 boco.family))

                        # jHigh
                        chkRange = [[s[0][i  ], s[0][i+1]],
                                    [s[1][j+1], s[1][j+1]],
                                    [s[2][k]  , s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [dims[1], dims[1]], [1, dims[2]]],
                                boco.family))

                        # kLow
                        chkRange = [[s[0][i], s[0][i+1]],
                                    [s[1][j], s[1][j+1]],
                                    [s[2][k], s[2][k]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, dims[1]], [1, 1]],
                                 boco.family))

                        # kHigh
                        chkRange = [[s[0][i]  , s[0][i+1]],
                                    [s[1][j]  , s[1][j+1]],
                                    [s[2][k+1], s[2][k+1]]]
                        
                        if inRange(boco.ptRange, chkRange):
                            blk.addBoco(Boco(
                                boco.name, boco.type,
                                [[1, dims[0]], [1, dims[1]], [dims[2], dims[2]]],
                                 boco.family))

                    blkList.append(blk)
        return blkList
    
    def divide(self):
        """Return a list of 8 blocks split derivied from the current
        block. Boundary condition information is kept, but
        connectivity information is removed"""

        # Just add the splits and run getSplitBlocks
        for iDim in range(3):
            self.splits[iDim].append((self.dims[iDim]-1)//2 + 1)
            self.splits[iDim].sort()
            
        return self.getSplitBlocks()
    
    def removeSymBCs(self):
        """Remove any sym BC's there may be"""
        self.bocos = [boco for boco in self.bocos 
                      if not boco.type == BC['bcsymmetryplane']]

    def extractWallSurfaces(self):
        """Return patches for any surfaces that have BCViscous on them"""
        patches = []
        for boco in self.bocos:
            if isWall(boco.type):
                ptRange = boco.ptRange - 1 # Convert to python ordering
                patches.append(self.coords[
                    ptRange[0, 0]:ptRange[0, 1]+1, 
                    ptRange[1, 0]:ptRange[1, 1]+1, 
                    ptRange[2, 0]:ptRange[2, 1]+1, :].squeeze())
                # Make sure the patch is correctly orientated since we
                # might have left-handed faces. Essentially we have to
                # flip an index on any "high" boundary condition:

                if ((ptRange[0, 0] == ptRange[0, 1] and 
                     ptRange[0, 0]+1 == self.dims[0]) or 
                    (ptRange[1, 0] == ptRange[1, 1] and 
                     ptRange[1, 0]+1 == 1) or 
                    (ptRange[2, 0] == ptRange[2, 1] and 
                     ptRange[2, 0]+1 == self.dims[2])):
                    patches[-1] = patches[-1][::-1, :, :]

        return patches

    def overwriteFamily(self, faceStr, family):
        """Possibly overwrite the family in the bocos if possible"""
        for boco in self.bocos:
            r = boco.ptRange
            match = (
                (r[0][0] == r[0][1] == 1 and faceStr == 'ilow') or
                (r[0][0] == r[0][1] == self.dims[0] and faceStr == 'ihigh') or
                (r[1][0] == r[1][1] == 1 and faceStr == 'jlow') or
                (r[1][0] == r[1][1] == self.dims[1] and faceStr == 'jhigh') or
                (r[2][0] == r[2][1] == 1 and faceStr == 'klow') or
                (r[2][0] == r[2][1] == self.dims[2] and faceStr == 'khigh'))

            if match:
                boco.family = family

    def overwriteBCs(self, faceStr, bcType, family, data):
        """Find any BCs on this face and toast them. Note that we *ONLY ALLOW
        ONE BC per face*
        """
        
        # Check for existing boco and pop if necessary
        pop_list = []
        for index in range(len(self.bocos)):
            boco = self.bocos[index]
            r = boco.ptRange
            match = (
                (r[0][0] == r[0][1] == 1 and faceStr == 'ilow') or
                (r[0][0] == r[0][1] == self.dims[0] and faceStr == 'ihigh') or
                (r[1][0] == r[1][1] == 1 and faceStr == 'jlow') or
                (r[1][0] == r[1][1] == self.dims[1] and faceStr == 'jhigh') or
                (r[2][0] == r[2][1] == 1 and faceStr == 'klow') or
                (r[2][0] == r[2][1] == self.dims[2] and faceStr == 'khigh'))

            if match:
                pop_list = pop_list + [index]

        # Pop all bcs in the face
        pop_list.reverse() # We have to remove the hogher indices first
        for index in pop_list:
            self.bocos.pop(index)

        d = self.dims
        faceStr = faceStr.lower()
        if faceStr == 'ilow':
            ptRange = [[1, 1, 1], [1, d[1], d[2]]]
        elif faceStr == 'ihigh':
            ptRange = [[d[0], 1, 1], [d[0], d[1], d[2]]]
        elif faceStr == 'jlow':
            ptRange = [[1, 1, 1], [d[0], 1, d[2]]]
        elif faceStr == 'jhigh':
            ptRange = [[1, d[1], 1], [d[0], d[1], d[2]]]
        elif faceStr == 'klow':
            ptRange = [[1, 1, 1], [d[0], d[1], 1]]
        elif faceStr == 'khigh':
            ptRange = [[1, 1, d[2]], [d[0], d[1], d[2]]]
        ptRange = numpy.array(ptRange).T
        newBoco = Boco("boco_%d"%self.bocoCounter, BC[bcType.lower()], 
                       ptRange, family, data)
        self.bocoCounter += 1
        self.bocos.append(newBoco)


    def rebunch(self, spacing, extraCells, nStar):
        """Perform rebunching for this block"""
        from pyspline import Curve

        # ********* WARNING THIS HARD CODED TO K-MIN PLANES *********
        self.dims[2] += extraCells
        if nStar == -1:
            nStar = self.dims[2]
            
        newNodes = numpy.zeros((self.dims[0], self.dims[1], self.dims[2] ,3))
        for i in range(self.dims[0]):
            for j in range(self.dims[1]):

                xx = self.coords[i, j, :, :]
                c = Curve(X=xx, localInterp=True)
                # First get the distance off-wall:
                d = numpy.linalg.norm(self.coords[i, j, 0, :] -
                                      self.coords[i, j, 1, :])
        
                # This is the segment of S we are dealing with:
                sSegment = c.s[0:nStar]

                # Compute the new S0
                s0 = (spacing / d)*c.s[1]
                # Get the newS. 
                newS = getS(len(sSegment) + extraCells + 1, s0, sSegment[-1])
                # The final 's' for evaluation
                newS = numpy.hstack([newS, c.s[nStar+1:]])
                newNodes[i, j, :, :] = c(newS)

        self.coords = newNodes

    def randomize(self):
        """Randomly reorder the indices in the block. No attempt is made to
        change BCs or B2Bs since these should be deleted already
        """

        if numpy.random.random() > 0.5:
            # We will flip the i-index
            for k in range(self.dims[2]):
                for j in range(self.dims[1]):
                    for idim in range(3):
                        self.coords[:, j, k, idim] = self.coords[::-1, j, k, idim]

        if numpy.random.random() > 0.5:
            # We will flip the j-index
            for k in range(self.dims[2]):
                for i in range(self.dims[0]):
                    for idim in range(3):
                        self.coords[i, :, k, idim] = self.coords[i, ::-1, k, idim]

        if numpy.random.random() > 0.5:
            # We will flip the k-index
            for j in range(self.dims[1]):
                for i in range(self.dims[0]):
                    for idim in range(3):
                        self.coords[i, j, :, idim] = self.coords[i, j, ::-1, idim]
        
        # So that filps the order of the axis. We can also perform
        # axis swapping. 
        if numpy.random.random() > 0.5:
            # Swap X and Y axis
            newCoords = numpy.zeros((self.dims[1], self.dims[0], self.dims[2], 3))
            for k in range(self.dims[2]):
                for idim in range(3):
                    newCoords[:, :, k, idim] = numpy.rot90(self.coords[:, :, k, idim].copy())

            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()

        if numpy.random.random() > 0.5:
            # Swap Z and X axis
            newCoords = numpy.zeros((self.dims[2], self.dims[1], self.dims[0], 3))
            for j in range(self.dims[1]):
                for idim in range(3):
                    newCoords[:, j, :, idim] = numpy.rot90(self.coords[:, j, :, idim])

            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()
            
        if numpy.random.random() > 0.5:
            # Swap Y and Z axis
            newCoords = numpy.zeros((self.dims[0], self.dims[2], self.dims[1], 3))
            for i in range(self.dims[0]):
                for idim in range(3):
                    newCoords[i, :, :, idim] = numpy.rot90(self.coords[i, :, :, idim])
                
            self.dims = list(newCoords.shape[0:3])
            self.coords = newCoords.copy()

    def symmZero(self, idir):
        for bc in self.bocos:
            if bc.type == BC['bcsymmetryplane']:
                # 'r' is the range. We need to subtract off -1 from
                # the low end since it was in fortran 1-based ordering
                r = bc.ptRange.copy()
                self.coords[r[0,0]-1:r[0,1], 
                            r[1,0]-1:r[1,1], 
                            r[2,0]-1:r[2,1], idir] = 0.0

    def getFaceCoords(self, blockID):
        """Return the list of coordinates on the face as well as its index info"""

        il = self.dims[0]
        jl = self.dims[1]
        kl = self.dims[2]
        nFace = 2*(  (il-1)*(jl-1) + (il-1)*(kl-1) + (jl-1)*(kl-1))

        return libcgns_utils.computefacecoords(self.coords, nFace, blockID)
      
class Boco(object):

    """Class for storing information related to a boundary condition"""
    def __init__(self, bocoName, bocoType, ptRange, family, bcData=None):
        self.name = bocoName.strip()
        self.type = bocoType
        self.ptRange = ptRange
        self.data = {}

        if family is None or family.strip() == '':
            self.family = 'default'
        else:
            self.family = family

    def coarsen(self):
        """Coarsen the range of the BC"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)//2 + 1

    def refine(self):
        """refine the range of the BC"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)*2 + 1


class B2B(object):
    """Class for storing information related to a Block-to-block or
    (1to1 in cgns speak) connection"""
    def __init__(self, connectName, donorName, ptRange, donorRange, transform):
        self.name = connectName.strip()
        self.donorName = donorName.strip()
        self.ptRange = ptRange
        self.donorRange = donorRange
        self.transform = transform

    def coarsen(self):
        """Coarsen the range of the B2B"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)//2 + 1
                self.donorRange[i, j] = (self.donorRange[i, j]-1)//2 + 1
    def refine(self):
        """refine the range of the B2B"""
        for i in range(3):
            for j in range(2):
                self.ptRange[i, j] = (self.ptRange[i, j]-1)*2 + 1
                self.donorRange[i, j] = (self.donorRange[i, j]-1)*2 + 1


# ----------------------------------------
# These are miscellaneous helper functions
# ----------------------------------------
def isWall(bc):
    """Determine if a bc is a wall-type boundary condition"""
    if (bc == BC['bcwall'] or 
        bc == BC['bcwallinviscid'] or 
        bc == BC['bcwallviscous'] or 
        bc == BC['bcwallviscousheatflux'] or 
        bc == BC['bcwallviscousisothermal']):
        return True
    else:
        return False

def getS(N, s0, S):
    """Determine the new set of parameters that geometrically fit N
    nodes with the last distance S"""
    
    # function 'f' is 1 - s0*(1-r^n)/(1-r), s0 is initial ratio and r
    # is the grid ratio.

    M = N-1
    # Bisection search:
    a = 1.0 + 1e-8
    b = 4.0

    def f(r):
        s = numpy.zeros(N)
        s[1]= s0
        for i in range(2, N):
            s[i] = s[i-1] + r*(s[i-1] - s[i-2])

        return s[-1]

    fa = S - f(a)
    fb = S - f(b)

    for i in range(100):
        c = 0.5*(a + b)
        ff = S - f(c)
        if abs(ff) < 1e-6:
            break
     
        if ff * fa > 0:
            a = c
        else:
            b = c
    s = numpy.zeros(N)
    s[1] = s0
  
    for i in range(2, N):
        s[i] = s[i-1] + c*(s[i-1] - s[i-2])

    return s
  
def getSplits(ptRange):
    """Return info required to split this face to make it face
    matched"""
    if ptRange[0][0] == ptRange[0][1]:
        splits = [(1, ptRange[1][0]), 
                  (1, ptRange[1][1]), 
                  (2, ptRange[2][0]), 
                  (2, ptRange[2][1])]
    elif ptRange[1][0] == ptRange[1][1]:
        splits = [(0, ptRange[0][0]), 
                  (0, ptRange[0][1]), 
                  (2, ptRange[2][0]), 
                  (2, ptRange[2][1])]
    elif ptRange[2][0] == ptRange[2][1]:
        splits = [(0, ptRange[0][0]), 
                  (0, ptRange[0][1]), 
                  (1, ptRange[1][0]), 
                  (1, ptRange[1][1])]
    return splits

def generalizedCoordDir(iFace):
    """Not really sure how this works..."""
    if iFace in [0, 1]:
        return [0, 1, 2]
    elif iFace in [2, 3]:
        return [1, 2, 0]
    elif iFace in [4, 5]:
        return [0, 2, 1]

def isodd(num):
    """check if a number is odd"""
    return num & 1 and True or False

def getPointRange(iFace, dims):
    """Return the correct point range for face iFace on a block with
    dimensions given in dims"""
    il = dims[0]
    jl = dims[1]
    kl = dims[2]
    if iFace == 0:
        return [[1, il], [1, jl], [1, 1]]
    elif iFace == 1:
        return [[1, il], [1, jl], [kl, kl]]
    elif iFace == 2:
        return [[1, 1], [1, jl], [1, kl]]
    elif iFace == 3:
        return [[il, il], [1, jl], [1, kl]]
    elif iFace == 4:
        return [[1, il], [1, 1], [1, kl]]
    elif iFace == 5:
        return [[1, il], [jl, jl], [1, kl]]

def inRange(ptRange, chkRange):
    """Determine if 'chkRange' fully overlaps with 'ptRange'"""
    val = True
    for iDim in range(3):
        if not (chkRange[iDim][0] >= ptRange[iDim][0] and 
                chkRange[iDim][1] <= ptRange[iDim][1]):
            val = False

    return val
             
# def normal_direction(iFace1, iFace2):
#     """Normal direction is positive if iFace1 and iFace two are of
#     opposite oddity, even if they are the same oddity"""
#     isOdd1 = isodd(iFace1)
#     isOdd2 = isodd(iFace2)

#     if isOdd1 is True and isOdd2 is True:
#         return -1
#     if isOdd1 is False and isOdd2 is False:
#         return -1

#     # otherwise:
#     return 1

# -----------------------------------------------------------------
# These functions perform operations that return new 'Grid' objects
# -----------------------------------------------------------------
def readGrid(fileName):
    """Internal routine to return a 'grid' object that contains all
    the information that is in the file 'fileName'"""

    inFile = libcgns_utils.openfile(fileName, CG_MODE_READ)
    cellDim = libcgns_utils.getgriddimension(inFile)
    nBlock = libcgns_utils.getnblocks(inFile)
    newGrid = Grid()
    
    for iBlock in range(1, nBlock+1):
        zoneName, dims, nBoco, nB2B = libcgns_utils.getblockinfo(inFile, iBlock)
        if cellDim == 2:
            dims[2] = 1
        coords = libcgns_utils.getcoordinates(inFile, iBlock,
                                              dims[0], dims[1], dims[2])
        blk = Block(zoneName, dims, coords)

        for iBoco in range(1, nBoco+1):
            bocoName, bocoType, ptRange, family = libcgns_utils.getbcinfo(
                inFile, iBlock, iBoco)
            blk.addBoco(Boco(bocoName, bocoType, ptRange, family))
        for iB2B in range(1, nB2B+1):
            connectName, donorName, ptRange, donorRange, transform = \
                         libcgns_utils.getb2binfo(inFile, iBlock, iB2B)
            blk.addB2B(B2B(connectName, donorName, ptRange, donorRange,
                           transform))
       
        newGrid.addBlock(blk)

    libcgns_utils.closefile(inFile)

    return newGrid

def mirrorGrid(grid, axis):
    """Method that takes a grid and mirrors about the axis. Boundary
    condition information is retained if possible"""

    # First make sure the grid is face matched:
    grid.split([])

    # Now copy original blocks
    newGrid = Grid()
    for blk in grid.blocks:
        blk.removeSymBCs()
        blk.B2Bs = []
        newGrid.addBlock(blk)

        mirrorBlk = copy.deepcopy(blk)
        mirrorBlk.flip(axis)
        newGrid.addBlock(mirrorBlk)

    # Now rename the blocks and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def divideGrid(grid):
    """Method that takes a grid and generates a new grid with 8 times
    as many blocks"""
    newGrid = Grid()
    for blk in grid.blocks:
        newBlks = blk.divide()
        for nblk in newBlks:
            newGrid.addBlock(nblk)

    # Now rename the blocks and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def splitGrid(grid, splitFile):
    """Method that takes a grid and propagates any splits using
    connectivity information. This is a rewrite of the original
    Fortran implementation that is quite a bit simpler due to Python"""
    # Split the current grid
    extraSplits = []
    if splitFile is not None:
        f = open(splitFile,'r')
        for line in f:
            aux = line.split()
            extraSplits.append([int(aux[0]), int(aux[1]), int(aux[2])])
        f.close()
    grid.split(extraSplits=extraSplits)

    # New grid
    newGrid = Grid()
    for blk in grid.blocks:
        newBlks = blk.getSplitBlocks()
        for nblk in newBlks:
            newGrid.addBlock(nblk)

    # # Now rename the blocks, bcs and redo-connectivity
    newGrid.renameBlocks()
    newGrid.renameBCs()
    newGrid.connect()

    return newGrid

def combineGrids(grids):
    """Method that takes in a list of grids and returns a new grid object
    containing all zones from each grid. The blocks are renamed as
    there could (almost most certainly) be conflicts between the zone
    names in the different grids. This also means that the block to
    block connectivities need to be updated based on the new zone names
    """

    # First determine the total number of blocks
    nBlock = 0
    newGrid = Grid()

    for grid in grids:

        # Mapping of the old names to the new names
        zoneMap = {}

        for blk in grid.blocks:
            nBlock += 1
            newName = 'domain.%5.5d'% nBlock
            zoneMap[blk.name] = newName
            blk.name = newName

        # Now loop back over the blocks, replacing the donorName using
        # the map we defined above
        for blk in grid.blocks:
            for b2b in blk.B2Bs:
                b2b.donorName = zoneMap[b2b.donorName]
                
        # Now add the new processed blocks to our newgrid
        newGrid.blocks.extend(grid.blocks)

    return newGrid


# -------------------------------------------
#         Selection of the task
# -------------------------------------------

# The time combine is special. First we generate the list of files we
# need to deal with. 
if args.mode == 'timecombine':
    # Get the directory name where the baseName is:
    path = os.path.dirname(os.path.abspath(args.baseName))

    # Get the full list of files in this directory:
    allFiles = [ f for f in os.listdir(path) if os.path.isfile(os.path.join(path,f)) ]
    files = []

    parts = args.baseName.split("%d")
    maxLength = 0
    for f in allFiles:
        if ((parts[0] == '' or parts[0] in f) and
            (parts[1] == '' or parts[1] in f)):
            # Make sure there is a .cgns in there somwhere
            if '.cgns' in f:
                files.append(f)
                maxLength = max(maxLength,len(f))
                files = sorted(files)

    if args.outFile is None:
        outFile = 'unsteady.plt'
    else:
        outFile = args.outFile

    # Now we make a character array of the file names, and hand if off to
    # fortran for all the actual reading/writing. 
    fileNames = numpy.zeros((len(files), 256), 'c')
    for i in range(len(files)):
        fileNames[i, 0:len(files[i])] = files[i]

    libcgns_utils.time_combine(fileNames, outFile)
    sys.exit(0)


# The 'combine' function is done first sicne it is the only function
# that reads multiple cgns files. 
if args.mode == 'combine':
    grids = []
    for fName in args.gridFiles:
        grid = readGrid(fName)
        grids.append(grid)
        
    combinedGrid = combineGrids(grids)
    combinedGrid.writeToCGNS(args.outFile)

    # This task is now finished
    sys.exit(0)

# Get the current working grid 'curGrid' by reading the input
curGrid = readGrid(args.gridFile)

# The following are "special" and done first since they do not
# have a CGNS output.

if args.mode == 'extract':
    curGrid.extractSurface(args.surfFile)
    sys.exit(0)

if args.mode == 'cgns2plot3d':
    curGrid.writePlot3d(args.plot3dFile)
    sys.exit(0)

# Determine if we have an output file:
if args.outFile is None:
    # Determine where to put a file:
    dirpath = tempfile.mkdtemp()

    # Define a temp output file
    outFileName = os.path.join(dirpath, 'tmp.cgns')
else:
    outFileName = args.outFile

# Perform one of the following actions:
if args.mode == 'flip':
    curGrid.flip(args.axis)

elif args.mode == 'scale':
    curGrid.scale(args.scale)

elif args.mode == 'mirror':
    curGrid = mirrorGrid(curGrid, args.axis)

elif args.mode == 'coarsen':
    curGrid.coarsen()

elif args.mode == 'refine':
    curGrid.refine()

elif args.mode == 'split':
    curGrid = splitGrid(curGrid, args.splitFile)

elif args.mode == 'connect':
    curGrid.connect()

elif args.mode == 'divide':
    curGrid = divideGrid(curGrid)

elif args.mode == 'autobc':
    curGrid.autoBC(args.radius, args.sym,
                   [args.xOffset, args.yOffset, args.zOffset])

elif args.mode == 'family':
    curGrid.overwriteFamilies(args.familyFile)

elif args.mode == 'familycopy':
    sourceGrid = readGrid(args.sourceFile)
    curGrid.copyFamilyInfo(sourceGrid)

elif args.mode == 'overwritebc':
    curGrid.overwriteBCs(args.bcFile)

elif args.mode == 'rebunch':
    curGrid.rebunch(args.spacing, args.extraCells, args.nodes)

elif args.mode == 'randomize':
    curGrid.randomize(args.seed)

elif args.mode == 'symmzero':
    curGrid.symmZero(args.sym)

elif args.mode == 'double2d':
    curGrid.double2D()

elif args.mode == 'cartesian':
    found_overset = False
    for block in curGrid.blocks:
        for boco in block.bocos:
            if boco.type == BC['bcoverset']:
                found_overset = True
    if found_overset:
        curGrid.cartesian(args.cartFile,args.outFile)
    else:
        print ('The CGNS file has no overset boundary conditions')
    sys.exit(0)

elif args.mode == 'translate':
    curGrid.translate(args.dx, args.dy, args.dz)

elif args.mode == 'autoOversetBC':
    curGrid.autoOversetBC(args.sym)

elif args.mode == 'autoNearfieldBC':
    curGrid.autoNearfieldBC(args.sym)

# Write out the grid.
curGrid.writeToCGNS(outFileName)

# Possibly copy back to the original:
if args.outFile is None:
    shutil.copyfile(outFileName, args.gridFile)
